// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_data_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "resources.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_data_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_data_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_data_2eproto;
namespace api_pb {
class AddLimitOrderData;
struct AddLimitOrderDataDefaultTypeInternal;
extern AddLimitOrderDataDefaultTypeInternal _AddLimitOrderData_default_instance_;
class AddLiquidityData;
struct AddLiquidityDataDefaultTypeInternal;
extern AddLiquidityDataDefaultTypeInternal _AddLiquidityData_default_instance_;
class BurnTokenData;
struct BurnTokenDataDefaultTypeInternal;
extern BurnTokenDataDefaultTypeInternal _BurnTokenData_default_instance_;
class BuyCoinData;
struct BuyCoinDataDefaultTypeInternal;
extern BuyCoinDataDefaultTypeInternal _BuyCoinData_default_instance_;
class BuySwapPoolData;
struct BuySwapPoolDataDefaultTypeInternal;
extern BuySwapPoolDataDefaultTypeInternal _BuySwapPoolData_default_instance_;
class CreateCoinData;
struct CreateCoinDataDefaultTypeInternal;
extern CreateCoinDataDefaultTypeInternal _CreateCoinData_default_instance_;
class CreateMultisigData;
struct CreateMultisigDataDefaultTypeInternal;
extern CreateMultisigDataDefaultTypeInternal _CreateMultisigData_default_instance_;
class CreateSwapPoolData;
struct CreateSwapPoolDataDefaultTypeInternal;
extern CreateSwapPoolDataDefaultTypeInternal _CreateSwapPoolData_default_instance_;
class CreateTokenData;
struct CreateTokenDataDefaultTypeInternal;
extern CreateTokenDataDefaultTypeInternal _CreateTokenData_default_instance_;
class DeclareCandidacyData;
struct DeclareCandidacyDataDefaultTypeInternal;
extern DeclareCandidacyDataDefaultTypeInternal _DeclareCandidacyData_default_instance_;
class DelegateData;
struct DelegateDataDefaultTypeInternal;
extern DelegateDataDefaultTypeInternal _DelegateData_default_instance_;
class EditCandidateCommission;
struct EditCandidateCommissionDefaultTypeInternal;
extern EditCandidateCommissionDefaultTypeInternal _EditCandidateCommission_default_instance_;
class EditCandidateData;
struct EditCandidateDataDefaultTypeInternal;
extern EditCandidateDataDefaultTypeInternal _EditCandidateData_default_instance_;
class EditCandidatePublicKeyData;
struct EditCandidatePublicKeyDataDefaultTypeInternal;
extern EditCandidatePublicKeyDataDefaultTypeInternal _EditCandidatePublicKeyData_default_instance_;
class EditCoinOwnerData;
struct EditCoinOwnerDataDefaultTypeInternal;
extern EditCoinOwnerDataDefaultTypeInternal _EditCoinOwnerData_default_instance_;
class EditMultisigData;
struct EditMultisigDataDefaultTypeInternal;
extern EditMultisigDataDefaultTypeInternal _EditMultisigData_default_instance_;
class MintTokenData;
struct MintTokenDataDefaultTypeInternal;
extern MintTokenDataDefaultTypeInternal _MintTokenData_default_instance_;
class MultiSendData;
struct MultiSendDataDefaultTypeInternal;
extern MultiSendDataDefaultTypeInternal _MultiSendData_default_instance_;
class RecreateCoinData;
struct RecreateCoinDataDefaultTypeInternal;
extern RecreateCoinDataDefaultTypeInternal _RecreateCoinData_default_instance_;
class RecreateTokenData;
struct RecreateTokenDataDefaultTypeInternal;
extern RecreateTokenDataDefaultTypeInternal _RecreateTokenData_default_instance_;
class RedeemCheckData;
struct RedeemCheckDataDefaultTypeInternal;
extern RedeemCheckDataDefaultTypeInternal _RedeemCheckData_default_instance_;
class RemoveLimitOrderData;
struct RemoveLimitOrderDataDefaultTypeInternal;
extern RemoveLimitOrderDataDefaultTypeInternal _RemoveLimitOrderData_default_instance_;
class RemoveLiquidityData;
struct RemoveLiquidityDataDefaultTypeInternal;
extern RemoveLiquidityDataDefaultTypeInternal _RemoveLiquidityData_default_instance_;
class SellAllCoinData;
struct SellAllCoinDataDefaultTypeInternal;
extern SellAllCoinDataDefaultTypeInternal _SellAllCoinData_default_instance_;
class SellAllSwapPoolData;
struct SellAllSwapPoolDataDefaultTypeInternal;
extern SellAllSwapPoolDataDefaultTypeInternal _SellAllSwapPoolData_default_instance_;
class SellCoinData;
struct SellCoinDataDefaultTypeInternal;
extern SellCoinDataDefaultTypeInternal _SellCoinData_default_instance_;
class SellSwapPoolData;
struct SellSwapPoolDataDefaultTypeInternal;
extern SellSwapPoolDataDefaultTypeInternal _SellSwapPoolData_default_instance_;
class SendData;
struct SendDataDefaultTypeInternal;
extern SendDataDefaultTypeInternal _SendData_default_instance_;
class SetCandidateOffData;
struct SetCandidateOffDataDefaultTypeInternal;
extern SetCandidateOffDataDefaultTypeInternal _SetCandidateOffData_default_instance_;
class SetCandidateOnData;
struct SetCandidateOnDataDefaultTypeInternal;
extern SetCandidateOnDataDefaultTypeInternal _SetCandidateOnData_default_instance_;
class SetHaltBlockData;
struct SetHaltBlockDataDefaultTypeInternal;
extern SetHaltBlockDataDefaultTypeInternal _SetHaltBlockData_default_instance_;
class UnbondData;
struct UnbondDataDefaultTypeInternal;
extern UnbondDataDefaultTypeInternal _UnbondData_default_instance_;
class VoteCommissionData;
struct VoteCommissionDataDefaultTypeInternal;
extern VoteCommissionDataDefaultTypeInternal _VoteCommissionData_default_instance_;
class VoteUpdateData;
struct VoteUpdateDataDefaultTypeInternal;
extern VoteUpdateDataDefaultTypeInternal _VoteUpdateData_default_instance_;
}  // namespace api_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::api_pb::AddLimitOrderData* Arena::CreateMaybeMessage<::api_pb::AddLimitOrderData>(Arena*);
template<> ::api_pb::AddLiquidityData* Arena::CreateMaybeMessage<::api_pb::AddLiquidityData>(Arena*);
template<> ::api_pb::BurnTokenData* Arena::CreateMaybeMessage<::api_pb::BurnTokenData>(Arena*);
template<> ::api_pb::BuyCoinData* Arena::CreateMaybeMessage<::api_pb::BuyCoinData>(Arena*);
template<> ::api_pb::BuySwapPoolData* Arena::CreateMaybeMessage<::api_pb::BuySwapPoolData>(Arena*);
template<> ::api_pb::CreateCoinData* Arena::CreateMaybeMessage<::api_pb::CreateCoinData>(Arena*);
template<> ::api_pb::CreateMultisigData* Arena::CreateMaybeMessage<::api_pb::CreateMultisigData>(Arena*);
template<> ::api_pb::CreateSwapPoolData* Arena::CreateMaybeMessage<::api_pb::CreateSwapPoolData>(Arena*);
template<> ::api_pb::CreateTokenData* Arena::CreateMaybeMessage<::api_pb::CreateTokenData>(Arena*);
template<> ::api_pb::DeclareCandidacyData* Arena::CreateMaybeMessage<::api_pb::DeclareCandidacyData>(Arena*);
template<> ::api_pb::DelegateData* Arena::CreateMaybeMessage<::api_pb::DelegateData>(Arena*);
template<> ::api_pb::EditCandidateCommission* Arena::CreateMaybeMessage<::api_pb::EditCandidateCommission>(Arena*);
template<> ::api_pb::EditCandidateData* Arena::CreateMaybeMessage<::api_pb::EditCandidateData>(Arena*);
template<> ::api_pb::EditCandidatePublicKeyData* Arena::CreateMaybeMessage<::api_pb::EditCandidatePublicKeyData>(Arena*);
template<> ::api_pb::EditCoinOwnerData* Arena::CreateMaybeMessage<::api_pb::EditCoinOwnerData>(Arena*);
template<> ::api_pb::EditMultisigData* Arena::CreateMaybeMessage<::api_pb::EditMultisigData>(Arena*);
template<> ::api_pb::MintTokenData* Arena::CreateMaybeMessage<::api_pb::MintTokenData>(Arena*);
template<> ::api_pb::MultiSendData* Arena::CreateMaybeMessage<::api_pb::MultiSendData>(Arena*);
template<> ::api_pb::RecreateCoinData* Arena::CreateMaybeMessage<::api_pb::RecreateCoinData>(Arena*);
template<> ::api_pb::RecreateTokenData* Arena::CreateMaybeMessage<::api_pb::RecreateTokenData>(Arena*);
template<> ::api_pb::RedeemCheckData* Arena::CreateMaybeMessage<::api_pb::RedeemCheckData>(Arena*);
template<> ::api_pb::RemoveLimitOrderData* Arena::CreateMaybeMessage<::api_pb::RemoveLimitOrderData>(Arena*);
template<> ::api_pb::RemoveLiquidityData* Arena::CreateMaybeMessage<::api_pb::RemoveLiquidityData>(Arena*);
template<> ::api_pb::SellAllCoinData* Arena::CreateMaybeMessage<::api_pb::SellAllCoinData>(Arena*);
template<> ::api_pb::SellAllSwapPoolData* Arena::CreateMaybeMessage<::api_pb::SellAllSwapPoolData>(Arena*);
template<> ::api_pb::SellCoinData* Arena::CreateMaybeMessage<::api_pb::SellCoinData>(Arena*);
template<> ::api_pb::SellSwapPoolData* Arena::CreateMaybeMessage<::api_pb::SellSwapPoolData>(Arena*);
template<> ::api_pb::SendData* Arena::CreateMaybeMessage<::api_pb::SendData>(Arena*);
template<> ::api_pb::SetCandidateOffData* Arena::CreateMaybeMessage<::api_pb::SetCandidateOffData>(Arena*);
template<> ::api_pb::SetCandidateOnData* Arena::CreateMaybeMessage<::api_pb::SetCandidateOnData>(Arena*);
template<> ::api_pb::SetHaltBlockData* Arena::CreateMaybeMessage<::api_pb::SetHaltBlockData>(Arena*);
template<> ::api_pb::UnbondData* Arena::CreateMaybeMessage<::api_pb::UnbondData>(Arena*);
template<> ::api_pb::VoteCommissionData* Arena::CreateMaybeMessage<::api_pb::VoteCommissionData>(Arena*);
template<> ::api_pb::VoteUpdateData* Arena::CreateMaybeMessage<::api_pb::VoteUpdateData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace api_pb {

// ===================================================================

class SendData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SendData) */ {
 public:
  inline SendData() : SendData(nullptr) {}
  ~SendData() override;
  explicit constexpr SendData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendData(const SendData& from);
  SendData(SendData&& from) noexcept
    : SendData() {
    *this = ::std::move(from);
  }

  inline SendData& operator=(const SendData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendData& operator=(SendData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendData* internal_default_instance() {
    return reinterpret_cast<const SendData*>(
               &_SendData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SendData& a, SendData& b) {
    a.Swap(&b);
  }
  inline void Swap(SendData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendData* New() const final {
    return new SendData();
  }

  SendData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SendData";
  }
  protected:
  explicit SendData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 2,
    kValueFieldNumber = 3,
    kCoinFieldNumber = 1,
  };
  // string to = 2 [json_name = "to"];
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_MUST_USE_RESULT std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // string value = 3 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .api_pb.Coin coin = 1 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // @@protoc_insertion_point(class_scope:api_pb.SendData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::api_pb::Coin* coin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SellCoinData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SellCoinData) */ {
 public:
  inline SellCoinData() : SellCoinData(nullptr) {}
  ~SellCoinData() override;
  explicit constexpr SellCoinData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellCoinData(const SellCoinData& from);
  SellCoinData(SellCoinData&& from) noexcept
    : SellCoinData() {
    *this = ::std::move(from);
  }

  inline SellCoinData& operator=(const SellCoinData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellCoinData& operator=(SellCoinData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellCoinData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellCoinData* internal_default_instance() {
    return reinterpret_cast<const SellCoinData*>(
               &_SellCoinData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SellCoinData& a, SellCoinData& b) {
    a.Swap(&b);
  }
  inline void Swap(SellCoinData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellCoinData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SellCoinData* New() const final {
    return new SellCoinData();
  }

  SellCoinData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SellCoinData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellCoinData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SellCoinData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellCoinData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SellCoinData";
  }
  protected:
  explicit SellCoinData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueToSellFieldNumber = 2,
    kMinimumValueToBuyFieldNumber = 4,
    kCoinToSellFieldNumber = 1,
    kCoinToBuyFieldNumber = 3,
  };
  // string value_to_sell = 2 [json_name = "valueToSell"];
  void clear_value_to_sell();
  const std::string& value_to_sell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_sell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_sell();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_sell();
  void set_allocated_value_to_sell(std::string* value_to_sell);
  private:
  const std::string& _internal_value_to_sell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_sell(const std::string& value);
  std::string* _internal_mutable_value_to_sell();
  public:

  // string minimum_value_to_buy = 4 [json_name = "minimumValueToBuy"];
  void clear_minimum_value_to_buy();
  const std::string& minimum_value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_value_to_buy();
  void set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy);
  private:
  const std::string& _internal_minimum_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_value_to_buy(const std::string& value);
  std::string* _internal_mutable_minimum_value_to_buy();
  public:

  // .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
  bool has_coin_to_sell() const;
  private:
  bool _internal_has_coin_to_sell() const;
  public:
  void clear_coin_to_sell();
  const ::api_pb::Coin& coin_to_sell() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_sell();
  ::api_pb::Coin* mutable_coin_to_sell();
  void set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell);
  private:
  const ::api_pb::Coin& _internal_coin_to_sell() const;
  ::api_pb::Coin* _internal_mutable_coin_to_sell();
  public:
  void unsafe_arena_set_allocated_coin_to_sell(
      ::api_pb::Coin* coin_to_sell);
  ::api_pb::Coin* unsafe_arena_release_coin_to_sell();

  // .api_pb.Coin coin_to_buy = 3 [json_name = "coinToBuy"];
  bool has_coin_to_buy() const;
  private:
  bool _internal_has_coin_to_buy() const;
  public:
  void clear_coin_to_buy();
  const ::api_pb::Coin& coin_to_buy() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_buy();
  ::api_pb::Coin* mutable_coin_to_buy();
  void set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy);
  private:
  const ::api_pb::Coin& _internal_coin_to_buy() const;
  ::api_pb::Coin* _internal_mutable_coin_to_buy();
  public:
  void unsafe_arena_set_allocated_coin_to_buy(
      ::api_pb::Coin* coin_to_buy);
  ::api_pb::Coin* unsafe_arena_release_coin_to_buy();

  // @@protoc_insertion_point(class_scope:api_pb.SellCoinData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_sell_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_value_to_buy_;
  ::api_pb::Coin* coin_to_sell_;
  ::api_pb::Coin* coin_to_buy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SellAllCoinData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SellAllCoinData) */ {
 public:
  inline SellAllCoinData() : SellAllCoinData(nullptr) {}
  ~SellAllCoinData() override;
  explicit constexpr SellAllCoinData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellAllCoinData(const SellAllCoinData& from);
  SellAllCoinData(SellAllCoinData&& from) noexcept
    : SellAllCoinData() {
    *this = ::std::move(from);
  }

  inline SellAllCoinData& operator=(const SellAllCoinData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellAllCoinData& operator=(SellAllCoinData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellAllCoinData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellAllCoinData* internal_default_instance() {
    return reinterpret_cast<const SellAllCoinData*>(
               &_SellAllCoinData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SellAllCoinData& a, SellAllCoinData& b) {
    a.Swap(&b);
  }
  inline void Swap(SellAllCoinData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellAllCoinData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SellAllCoinData* New() const final {
    return new SellAllCoinData();
  }

  SellAllCoinData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SellAllCoinData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellAllCoinData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SellAllCoinData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellAllCoinData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SellAllCoinData";
  }
  protected:
  explicit SellAllCoinData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumValueToBuyFieldNumber = 3,
    kCoinToSellFieldNumber = 1,
    kCoinToBuyFieldNumber = 2,
  };
  // string minimum_value_to_buy = 3 [json_name = "minimumValueToBuy"];
  void clear_minimum_value_to_buy();
  const std::string& minimum_value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_value_to_buy();
  void set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy);
  private:
  const std::string& _internal_minimum_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_value_to_buy(const std::string& value);
  std::string* _internal_mutable_minimum_value_to_buy();
  public:

  // .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
  bool has_coin_to_sell() const;
  private:
  bool _internal_has_coin_to_sell() const;
  public:
  void clear_coin_to_sell();
  const ::api_pb::Coin& coin_to_sell() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_sell();
  ::api_pb::Coin* mutable_coin_to_sell();
  void set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell);
  private:
  const ::api_pb::Coin& _internal_coin_to_sell() const;
  ::api_pb::Coin* _internal_mutable_coin_to_sell();
  public:
  void unsafe_arena_set_allocated_coin_to_sell(
      ::api_pb::Coin* coin_to_sell);
  ::api_pb::Coin* unsafe_arena_release_coin_to_sell();

  // .api_pb.Coin coin_to_buy = 2 [json_name = "coinToBuy"];
  bool has_coin_to_buy() const;
  private:
  bool _internal_has_coin_to_buy() const;
  public:
  void clear_coin_to_buy();
  const ::api_pb::Coin& coin_to_buy() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_buy();
  ::api_pb::Coin* mutable_coin_to_buy();
  void set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy);
  private:
  const ::api_pb::Coin& _internal_coin_to_buy() const;
  ::api_pb::Coin* _internal_mutable_coin_to_buy();
  public:
  void unsafe_arena_set_allocated_coin_to_buy(
      ::api_pb::Coin* coin_to_buy);
  ::api_pb::Coin* unsafe_arena_release_coin_to_buy();

  // @@protoc_insertion_point(class_scope:api_pb.SellAllCoinData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_value_to_buy_;
  ::api_pb::Coin* coin_to_sell_;
  ::api_pb::Coin* coin_to_buy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class BuyCoinData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.BuyCoinData) */ {
 public:
  inline BuyCoinData() : BuyCoinData(nullptr) {}
  ~BuyCoinData() override;
  explicit constexpr BuyCoinData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyCoinData(const BuyCoinData& from);
  BuyCoinData(BuyCoinData&& from) noexcept
    : BuyCoinData() {
    *this = ::std::move(from);
  }

  inline BuyCoinData& operator=(const BuyCoinData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyCoinData& operator=(BuyCoinData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyCoinData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyCoinData* internal_default_instance() {
    return reinterpret_cast<const BuyCoinData*>(
               &_BuyCoinData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BuyCoinData& a, BuyCoinData& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyCoinData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyCoinData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuyCoinData* New() const final {
    return new BuyCoinData();
  }

  BuyCoinData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuyCoinData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyCoinData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuyCoinData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyCoinData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.BuyCoinData";
  }
  protected:
  explicit BuyCoinData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueToBuyFieldNumber = 2,
    kMaximumValueToSellFieldNumber = 4,
    kCoinToBuyFieldNumber = 1,
    kCoinToSellFieldNumber = 3,
  };
  // string value_to_buy = 2 [json_name = "valueToBuy"];
  void clear_value_to_buy();
  const std::string& value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_buy();
  void set_allocated_value_to_buy(std::string* value_to_buy);
  private:
  const std::string& _internal_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_buy(const std::string& value);
  std::string* _internal_mutable_value_to_buy();
  public:

  // string maximum_value_to_sell = 4 [json_name = "maximumValueToSell"];
  void clear_maximum_value_to_sell();
  const std::string& maximum_value_to_sell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maximum_value_to_sell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maximum_value_to_sell();
  PROTOBUF_MUST_USE_RESULT std::string* release_maximum_value_to_sell();
  void set_allocated_maximum_value_to_sell(std::string* maximum_value_to_sell);
  private:
  const std::string& _internal_maximum_value_to_sell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maximum_value_to_sell(const std::string& value);
  std::string* _internal_mutable_maximum_value_to_sell();
  public:

  // .api_pb.Coin coin_to_buy = 1 [json_name = "coinToBuy"];
  bool has_coin_to_buy() const;
  private:
  bool _internal_has_coin_to_buy() const;
  public:
  void clear_coin_to_buy();
  const ::api_pb::Coin& coin_to_buy() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_buy();
  ::api_pb::Coin* mutable_coin_to_buy();
  void set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy);
  private:
  const ::api_pb::Coin& _internal_coin_to_buy() const;
  ::api_pb::Coin* _internal_mutable_coin_to_buy();
  public:
  void unsafe_arena_set_allocated_coin_to_buy(
      ::api_pb::Coin* coin_to_buy);
  ::api_pb::Coin* unsafe_arena_release_coin_to_buy();

  // .api_pb.Coin coin_to_sell = 3 [json_name = "coinToSell"];
  bool has_coin_to_sell() const;
  private:
  bool _internal_has_coin_to_sell() const;
  public:
  void clear_coin_to_sell();
  const ::api_pb::Coin& coin_to_sell() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_sell();
  ::api_pb::Coin* mutable_coin_to_sell();
  void set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell);
  private:
  const ::api_pb::Coin& _internal_coin_to_sell() const;
  ::api_pb::Coin* _internal_mutable_coin_to_sell();
  public:
  void unsafe_arena_set_allocated_coin_to_sell(
      ::api_pb::Coin* coin_to_sell);
  ::api_pb::Coin* unsafe_arena_release_coin_to_sell();

  // @@protoc_insertion_point(class_scope:api_pb.BuyCoinData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_buy_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maximum_value_to_sell_;
  ::api_pb::Coin* coin_to_buy_;
  ::api_pb::Coin* coin_to_sell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CreateCoinData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.CreateCoinData) */ {
 public:
  inline CreateCoinData() : CreateCoinData(nullptr) {}
  ~CreateCoinData() override;
  explicit constexpr CreateCoinData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCoinData(const CreateCoinData& from);
  CreateCoinData(CreateCoinData&& from) noexcept
    : CreateCoinData() {
    *this = ::std::move(from);
  }

  inline CreateCoinData& operator=(const CreateCoinData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCoinData& operator=(CreateCoinData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCoinData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCoinData* internal_default_instance() {
    return reinterpret_cast<const CreateCoinData*>(
               &_CreateCoinData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateCoinData& a, CreateCoinData& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCoinData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCoinData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCoinData* New() const final {
    return new CreateCoinData();
  }

  CreateCoinData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCoinData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCoinData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCoinData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCoinData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.CreateCoinData";
  }
  protected:
  explicit CreateCoinData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kInitialAmountFieldNumber = 3,
    kInitialReserveFieldNumber = 4,
    kMaxSupplyFieldNumber = 6,
    kConstantReserveRatioFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string symbol = 2 [json_name = "symbol"];
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string initial_amount = 3 [json_name = "initialAmount"];
  void clear_initial_amount();
  const std::string& initial_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_amount();
  void set_allocated_initial_amount(std::string* initial_amount);
  private:
  const std::string& _internal_initial_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_amount(const std::string& value);
  std::string* _internal_mutable_initial_amount();
  public:

  // string initial_reserve = 4 [json_name = "initialReserve"];
  void clear_initial_reserve();
  const std::string& initial_reserve() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_reserve(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_reserve();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_reserve();
  void set_allocated_initial_reserve(std::string* initial_reserve);
  private:
  const std::string& _internal_initial_reserve() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_reserve(const std::string& value);
  std::string* _internal_mutable_initial_reserve();
  public:

  // string max_supply = 6 [json_name = "maxSupply"];
  void clear_max_supply();
  const std::string& max_supply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_supply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_supply();
  PROTOBUF_MUST_USE_RESULT std::string* release_max_supply();
  void set_allocated_max_supply(std::string* max_supply);
  private:
  const std::string& _internal_max_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_supply(const std::string& value);
  std::string* _internal_mutable_max_supply();
  public:

  // uint64 constant_reserve_ratio = 5 [json_name = "constantReserveRatio"];
  void clear_constant_reserve_ratio();
  ::PROTOBUF_NAMESPACE_ID::uint64 constant_reserve_ratio() const;
  void set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_constant_reserve_ratio() const;
  void _internal_set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.CreateCoinData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_reserve_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_supply_;
  ::PROTOBUF_NAMESPACE_ID::uint64 constant_reserve_ratio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class DeclareCandidacyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.DeclareCandidacyData) */ {
 public:
  inline DeclareCandidacyData() : DeclareCandidacyData(nullptr) {}
  ~DeclareCandidacyData() override;
  explicit constexpr DeclareCandidacyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeclareCandidacyData(const DeclareCandidacyData& from);
  DeclareCandidacyData(DeclareCandidacyData&& from) noexcept
    : DeclareCandidacyData() {
    *this = ::std::move(from);
  }

  inline DeclareCandidacyData& operator=(const DeclareCandidacyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeclareCandidacyData& operator=(DeclareCandidacyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeclareCandidacyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeclareCandidacyData* internal_default_instance() {
    return reinterpret_cast<const DeclareCandidacyData*>(
               &_DeclareCandidacyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeclareCandidacyData& a, DeclareCandidacyData& b) {
    a.Swap(&b);
  }
  inline void Swap(DeclareCandidacyData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeclareCandidacyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeclareCandidacyData* New() const final {
    return new DeclareCandidacyData();
  }

  DeclareCandidacyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeclareCandidacyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeclareCandidacyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeclareCandidacyData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeclareCandidacyData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.DeclareCandidacyData";
  }
  protected:
  explicit DeclareCandidacyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPubKeyFieldNumber = 2,
    kStakeFieldNumber = 5,
    kCoinFieldNumber = 4,
    kCommissionFieldNumber = 3,
  };
  // string address = 1 [json_name = "address"];
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string pub_key = 2 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string stake = 5 [json_name = "stake"];
  void clear_stake();
  const std::string& stake() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stake(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stake();
  PROTOBUF_MUST_USE_RESULT std::string* release_stake();
  void set_allocated_stake(std::string* stake);
  private:
  const std::string& _internal_stake() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stake(const std::string& value);
  std::string* _internal_mutable_stake();
  public:

  // .api_pb.Coin coin = 4 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // uint64 commission = 3 [json_name = "commission"];
  void clear_commission();
  ::PROTOBUF_NAMESPACE_ID::uint64 commission() const;
  void set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_commission() const;
  void _internal_set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.DeclareCandidacyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stake_;
  ::api_pb::Coin* coin_;
  ::PROTOBUF_NAMESPACE_ID::uint64 commission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class DelegateData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.DelegateData) */ {
 public:
  inline DelegateData() : DelegateData(nullptr) {}
  ~DelegateData() override;
  explicit constexpr DelegateData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateData(const DelegateData& from);
  DelegateData(DelegateData&& from) noexcept
    : DelegateData() {
    *this = ::std::move(from);
  }

  inline DelegateData& operator=(const DelegateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateData& operator=(DelegateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateData* internal_default_instance() {
    return reinterpret_cast<const DelegateData*>(
               &_DelegateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DelegateData& a, DelegateData& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegateData* New() const final {
    return new DelegateData();
  }

  DelegateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegateData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegateData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegateData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.DelegateData";
  }
  protected:
  explicit DelegateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kValueFieldNumber = 3,
    kCoinFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string value = 3 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .api_pb.Coin coin = 2 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // @@protoc_insertion_point(class_scope:api_pb.DelegateData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::api_pb::Coin* coin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class UnbondData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.UnbondData) */ {
 public:
  inline UnbondData() : UnbondData(nullptr) {}
  ~UnbondData() override;
  explicit constexpr UnbondData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnbondData(const UnbondData& from);
  UnbondData(UnbondData&& from) noexcept
    : UnbondData() {
    *this = ::std::move(from);
  }

  inline UnbondData& operator=(const UnbondData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnbondData& operator=(UnbondData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnbondData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnbondData* internal_default_instance() {
    return reinterpret_cast<const UnbondData*>(
               &_UnbondData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnbondData& a, UnbondData& b) {
    a.Swap(&b);
  }
  inline void Swap(UnbondData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnbondData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnbondData* New() const final {
    return new UnbondData();
  }

  UnbondData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnbondData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnbondData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnbondData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnbondData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.UnbondData";
  }
  protected:
  explicit UnbondData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kValueFieldNumber = 3,
    kCoinFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string value = 3 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .api_pb.Coin coin = 2 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // @@protoc_insertion_point(class_scope:api_pb.UnbondData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::api_pb::Coin* coin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class RedeemCheckData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.RedeemCheckData) */ {
 public:
  inline RedeemCheckData() : RedeemCheckData(nullptr) {}
  ~RedeemCheckData() override;
  explicit constexpr RedeemCheckData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedeemCheckData(const RedeemCheckData& from);
  RedeemCheckData(RedeemCheckData&& from) noexcept
    : RedeemCheckData() {
    *this = ::std::move(from);
  }

  inline RedeemCheckData& operator=(const RedeemCheckData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedeemCheckData& operator=(RedeemCheckData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedeemCheckData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedeemCheckData* internal_default_instance() {
    return reinterpret_cast<const RedeemCheckData*>(
               &_RedeemCheckData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RedeemCheckData& a, RedeemCheckData& b) {
    a.Swap(&b);
  }
  inline void Swap(RedeemCheckData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedeemCheckData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedeemCheckData* New() const final {
    return new RedeemCheckData();
  }

  RedeemCheckData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedeemCheckData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedeemCheckData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedeemCheckData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedeemCheckData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.RedeemCheckData";
  }
  protected:
  explicit RedeemCheckData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawCheckFieldNumber = 1,
    kProofFieldNumber = 2,
  };
  // string raw_check = 1 [json_name = "rawCheck"];
  void clear_raw_check();
  const std::string& raw_check() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_check(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_check();
  PROTOBUF_MUST_USE_RESULT std::string* release_raw_check();
  void set_allocated_raw_check(std::string* raw_check);
  private:
  const std::string& _internal_raw_check() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_check(const std::string& value);
  std::string* _internal_mutable_raw_check();
  public:

  // string proof = 2 [json_name = "proof"];
  void clear_proof();
  const std::string& proof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proof();
  PROTOBUF_MUST_USE_RESULT std::string* release_proof();
  void set_allocated_proof(std::string* proof);
  private:
  const std::string& _internal_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof(const std::string& value);
  std::string* _internal_mutable_proof();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.RedeemCheckData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_check_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SetCandidateOnData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SetCandidateOnData) */ {
 public:
  inline SetCandidateOnData() : SetCandidateOnData(nullptr) {}
  ~SetCandidateOnData() override;
  explicit constexpr SetCandidateOnData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCandidateOnData(const SetCandidateOnData& from);
  SetCandidateOnData(SetCandidateOnData&& from) noexcept
    : SetCandidateOnData() {
    *this = ::std::move(from);
  }

  inline SetCandidateOnData& operator=(const SetCandidateOnData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCandidateOnData& operator=(SetCandidateOnData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCandidateOnData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCandidateOnData* internal_default_instance() {
    return reinterpret_cast<const SetCandidateOnData*>(
               &_SetCandidateOnData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetCandidateOnData& a, SetCandidateOnData& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCandidateOnData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCandidateOnData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetCandidateOnData* New() const final {
    return new SetCandidateOnData();
  }

  SetCandidateOnData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetCandidateOnData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCandidateOnData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetCandidateOnData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCandidateOnData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SetCandidateOnData";
  }
  protected:
  explicit SetCandidateOnData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.SetCandidateOnData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SetCandidateOffData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SetCandidateOffData) */ {
 public:
  inline SetCandidateOffData() : SetCandidateOffData(nullptr) {}
  ~SetCandidateOffData() override;
  explicit constexpr SetCandidateOffData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCandidateOffData(const SetCandidateOffData& from);
  SetCandidateOffData(SetCandidateOffData&& from) noexcept
    : SetCandidateOffData() {
    *this = ::std::move(from);
  }

  inline SetCandidateOffData& operator=(const SetCandidateOffData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCandidateOffData& operator=(SetCandidateOffData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCandidateOffData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCandidateOffData* internal_default_instance() {
    return reinterpret_cast<const SetCandidateOffData*>(
               &_SetCandidateOffData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetCandidateOffData& a, SetCandidateOffData& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCandidateOffData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCandidateOffData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetCandidateOffData* New() const final {
    return new SetCandidateOffData();
  }

  SetCandidateOffData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetCandidateOffData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCandidateOffData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetCandidateOffData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCandidateOffData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SetCandidateOffData";
  }
  protected:
  explicit SetCandidateOffData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.SetCandidateOffData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CreateMultisigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.CreateMultisigData) */ {
 public:
  inline CreateMultisigData() : CreateMultisigData(nullptr) {}
  ~CreateMultisigData() override;
  explicit constexpr CreateMultisigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateMultisigData(const CreateMultisigData& from);
  CreateMultisigData(CreateMultisigData&& from) noexcept
    : CreateMultisigData() {
    *this = ::std::move(from);
  }

  inline CreateMultisigData& operator=(const CreateMultisigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateMultisigData& operator=(CreateMultisigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateMultisigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateMultisigData* internal_default_instance() {
    return reinterpret_cast<const CreateMultisigData*>(
               &_CreateMultisigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateMultisigData& a, CreateMultisigData& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateMultisigData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateMultisigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateMultisigData* New() const final {
    return new CreateMultisigData();
  }

  CreateMultisigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateMultisigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateMultisigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateMultisigData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateMultisigData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.CreateMultisigData";
  }
  protected:
  explicit CreateMultisigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 2,
    kAddressesFieldNumber = 3,
    kThresholdFieldNumber = 1,
  };
  // repeated uint64 weights = 2 [json_name = "weights"];
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_weights(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_weights() const;
  void _internal_add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_weights();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 weights(int index) const;
  void set_weights(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      weights() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_weights();

  // repeated string addresses = 3 [json_name = "addresses"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // uint64 threshold = 1 [json_name = "threshold"];
  void clear_threshold();
  ::PROTOBUF_NAMESPACE_ID::uint64 threshold() const;
  void set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_threshold() const;
  void _internal_set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.CreateMultisigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > weights_;
  mutable std::atomic<int> _weights_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
  ::PROTOBUF_NAMESPACE_ID::uint64 threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MultiSendData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.MultiSendData) */ {
 public:
  inline MultiSendData() : MultiSendData(nullptr) {}
  ~MultiSendData() override;
  explicit constexpr MultiSendData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiSendData(const MultiSendData& from);
  MultiSendData(MultiSendData&& from) noexcept
    : MultiSendData() {
    *this = ::std::move(from);
  }

  inline MultiSendData& operator=(const MultiSendData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSendData& operator=(MultiSendData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiSendData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSendData* internal_default_instance() {
    return reinterpret_cast<const MultiSendData*>(
               &_MultiSendData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MultiSendData& a, MultiSendData& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSendData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSendData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiSendData* New() const final {
    return new MultiSendData();
  }

  MultiSendData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiSendData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiSendData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiSendData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSendData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.MultiSendData";
  }
  protected:
  explicit MultiSendData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .api_pb.SendData list = 1 [json_name = "list"];
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::api_pb::SendData* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::SendData >*
      mutable_list();
  private:
  const ::api_pb::SendData& _internal_list(int index) const;
  ::api_pb::SendData* _internal_add_list();
  public:
  const ::api_pb::SendData& list(int index) const;
  ::api_pb::SendData* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::SendData >&
      list() const;

  // @@protoc_insertion_point(class_scope:api_pb.MultiSendData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::SendData > list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class EditCandidateData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.EditCandidateData) */ {
 public:
  inline EditCandidateData() : EditCandidateData(nullptr) {}
  ~EditCandidateData() override;
  explicit constexpr EditCandidateData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCandidateData(const EditCandidateData& from);
  EditCandidateData(EditCandidateData&& from) noexcept
    : EditCandidateData() {
    *this = ::std::move(from);
  }

  inline EditCandidateData& operator=(const EditCandidateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCandidateData& operator=(EditCandidateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCandidateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCandidateData* internal_default_instance() {
    return reinterpret_cast<const EditCandidateData*>(
               &_EditCandidateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EditCandidateData& a, EditCandidateData& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCandidateData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCandidateData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditCandidateData* New() const final {
    return new EditCandidateData();
  }

  EditCandidateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditCandidateData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCandidateData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCandidateData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCandidateData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.EditCandidateData";
  }
  protected:
  explicit EditCandidateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kRewardAddressFieldNumber = 3,
    kOwnerAddressFieldNumber = 4,
    kControlAddressFieldNumber = 5,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string reward_address = 3 [json_name = "rewardAddress"];
  void clear_reward_address();
  const std::string& reward_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_reward_address();
  void set_allocated_reward_address(std::string* reward_address);
  private:
  const std::string& _internal_reward_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_address(const std::string& value);
  std::string* _internal_mutable_reward_address();
  public:

  // string owner_address = 4 [json_name = "ownerAddress"];
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // string control_address = 5 [json_name = "controlAddress"];
  void clear_control_address();
  const std::string& control_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_control_address();
  void set_allocated_control_address(std::string* control_address);
  private:
  const std::string& _internal_control_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_address(const std::string& value);
  std::string* _internal_mutable_control_address();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.EditCandidateData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SetHaltBlockData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SetHaltBlockData) */ {
 public:
  inline SetHaltBlockData() : SetHaltBlockData(nullptr) {}
  ~SetHaltBlockData() override;
  explicit constexpr SetHaltBlockData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetHaltBlockData(const SetHaltBlockData& from);
  SetHaltBlockData(SetHaltBlockData&& from) noexcept
    : SetHaltBlockData() {
    *this = ::std::move(from);
  }

  inline SetHaltBlockData& operator=(const SetHaltBlockData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetHaltBlockData& operator=(SetHaltBlockData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetHaltBlockData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetHaltBlockData* internal_default_instance() {
    return reinterpret_cast<const SetHaltBlockData*>(
               &_SetHaltBlockData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetHaltBlockData& a, SetHaltBlockData& b) {
    a.Swap(&b);
  }
  inline void Swap(SetHaltBlockData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetHaltBlockData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetHaltBlockData* New() const final {
    return new SetHaltBlockData();
  }

  SetHaltBlockData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetHaltBlockData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetHaltBlockData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetHaltBlockData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetHaltBlockData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SetHaltBlockData";
  }
  protected:
  explicit SetHaltBlockData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // uint64 height = 2 [json_name = "height"];
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.SetHaltBlockData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class RecreateCoinData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.RecreateCoinData) */ {
 public:
  inline RecreateCoinData() : RecreateCoinData(nullptr) {}
  ~RecreateCoinData() override;
  explicit constexpr RecreateCoinData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecreateCoinData(const RecreateCoinData& from);
  RecreateCoinData(RecreateCoinData&& from) noexcept
    : RecreateCoinData() {
    *this = ::std::move(from);
  }

  inline RecreateCoinData& operator=(const RecreateCoinData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecreateCoinData& operator=(RecreateCoinData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecreateCoinData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecreateCoinData* internal_default_instance() {
    return reinterpret_cast<const RecreateCoinData*>(
               &_RecreateCoinData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RecreateCoinData& a, RecreateCoinData& b) {
    a.Swap(&b);
  }
  inline void Swap(RecreateCoinData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecreateCoinData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecreateCoinData* New() const final {
    return new RecreateCoinData();
  }

  RecreateCoinData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecreateCoinData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecreateCoinData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecreateCoinData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecreateCoinData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.RecreateCoinData";
  }
  protected:
  explicit RecreateCoinData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kInitialAmountFieldNumber = 3,
    kInitialReserveFieldNumber = 4,
    kMaxSupplyFieldNumber = 6,
    kConstantReserveRatioFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string symbol = 2 [json_name = "symbol"];
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string initial_amount = 3 [json_name = "initialAmount"];
  void clear_initial_amount();
  const std::string& initial_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_amount();
  void set_allocated_initial_amount(std::string* initial_amount);
  private:
  const std::string& _internal_initial_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_amount(const std::string& value);
  std::string* _internal_mutable_initial_amount();
  public:

  // string initial_reserve = 4 [json_name = "initialReserve"];
  void clear_initial_reserve();
  const std::string& initial_reserve() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_reserve(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_reserve();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_reserve();
  void set_allocated_initial_reserve(std::string* initial_reserve);
  private:
  const std::string& _internal_initial_reserve() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_reserve(const std::string& value);
  std::string* _internal_mutable_initial_reserve();
  public:

  // string max_supply = 6 [json_name = "maxSupply"];
  void clear_max_supply();
  const std::string& max_supply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_supply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_supply();
  PROTOBUF_MUST_USE_RESULT std::string* release_max_supply();
  void set_allocated_max_supply(std::string* max_supply);
  private:
  const std::string& _internal_max_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_supply(const std::string& value);
  std::string* _internal_mutable_max_supply();
  public:

  // uint64 constant_reserve_ratio = 5 [json_name = "constantReserveRatio"];
  void clear_constant_reserve_ratio();
  ::PROTOBUF_NAMESPACE_ID::uint64 constant_reserve_ratio() const;
  void set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_constant_reserve_ratio() const;
  void _internal_set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.RecreateCoinData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_reserve_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_supply_;
  ::PROTOBUF_NAMESPACE_ID::uint64 constant_reserve_ratio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class EditCoinOwnerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.EditCoinOwnerData) */ {
 public:
  inline EditCoinOwnerData() : EditCoinOwnerData(nullptr) {}
  ~EditCoinOwnerData() override;
  explicit constexpr EditCoinOwnerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCoinOwnerData(const EditCoinOwnerData& from);
  EditCoinOwnerData(EditCoinOwnerData&& from) noexcept
    : EditCoinOwnerData() {
    *this = ::std::move(from);
  }

  inline EditCoinOwnerData& operator=(const EditCoinOwnerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCoinOwnerData& operator=(EditCoinOwnerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCoinOwnerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCoinOwnerData* internal_default_instance() {
    return reinterpret_cast<const EditCoinOwnerData*>(
               &_EditCoinOwnerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EditCoinOwnerData& a, EditCoinOwnerData& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCoinOwnerData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCoinOwnerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditCoinOwnerData* New() const final {
    return new EditCoinOwnerData();
  }

  EditCoinOwnerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditCoinOwnerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCoinOwnerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCoinOwnerData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCoinOwnerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.EditCoinOwnerData";
  }
  protected:
  explicit EditCoinOwnerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kNewOwnerFieldNumber = 2,
  };
  // string symbol = 1 [json_name = "symbol"];
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string new_owner = 2 [json_name = "newOwner"];
  void clear_new_owner();
  const std::string& new_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_owner();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_owner();
  void set_allocated_new_owner(std::string* new_owner);
  private:
  const std::string& _internal_new_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_owner(const std::string& value);
  std::string* _internal_mutable_new_owner();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.EditCoinOwnerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class EditMultisigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.EditMultisigData) */ {
 public:
  inline EditMultisigData() : EditMultisigData(nullptr) {}
  ~EditMultisigData() override;
  explicit constexpr EditMultisigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditMultisigData(const EditMultisigData& from);
  EditMultisigData(EditMultisigData&& from) noexcept
    : EditMultisigData() {
    *this = ::std::move(from);
  }

  inline EditMultisigData& operator=(const EditMultisigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditMultisigData& operator=(EditMultisigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditMultisigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditMultisigData* internal_default_instance() {
    return reinterpret_cast<const EditMultisigData*>(
               &_EditMultisigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EditMultisigData& a, EditMultisigData& b) {
    a.Swap(&b);
  }
  inline void Swap(EditMultisigData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditMultisigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditMultisigData* New() const final {
    return new EditMultisigData();
  }

  EditMultisigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditMultisigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditMultisigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditMultisigData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditMultisigData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.EditMultisigData";
  }
  protected:
  explicit EditMultisigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 2,
    kAddressesFieldNumber = 3,
    kThresholdFieldNumber = 1,
  };
  // repeated uint64 weights = 2 [json_name = "weights"];
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_weights(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_weights() const;
  void _internal_add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_weights();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 weights(int index) const;
  void set_weights(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      weights() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_weights();

  // repeated string addresses = 3 [json_name = "addresses"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // uint64 threshold = 1 [json_name = "threshold"];
  void clear_threshold();
  ::PROTOBUF_NAMESPACE_ID::uint64 threshold() const;
  void set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_threshold() const;
  void _internal_set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.EditMultisigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > weights_;
  mutable std::atomic<int> _weights_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
  ::PROTOBUF_NAMESPACE_ID::uint64 threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class EditCandidatePublicKeyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.EditCandidatePublicKeyData) */ {
 public:
  inline EditCandidatePublicKeyData() : EditCandidatePublicKeyData(nullptr) {}
  ~EditCandidatePublicKeyData() override;
  explicit constexpr EditCandidatePublicKeyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCandidatePublicKeyData(const EditCandidatePublicKeyData& from);
  EditCandidatePublicKeyData(EditCandidatePublicKeyData&& from) noexcept
    : EditCandidatePublicKeyData() {
    *this = ::std::move(from);
  }

  inline EditCandidatePublicKeyData& operator=(const EditCandidatePublicKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCandidatePublicKeyData& operator=(EditCandidatePublicKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCandidatePublicKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCandidatePublicKeyData* internal_default_instance() {
    return reinterpret_cast<const EditCandidatePublicKeyData*>(
               &_EditCandidatePublicKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EditCandidatePublicKeyData& a, EditCandidatePublicKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCandidatePublicKeyData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCandidatePublicKeyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditCandidatePublicKeyData* New() const final {
    return new EditCandidatePublicKeyData();
  }

  EditCandidatePublicKeyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditCandidatePublicKeyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCandidatePublicKeyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCandidatePublicKeyData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCandidatePublicKeyData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.EditCandidatePublicKeyData";
  }
  protected:
  explicit EditCandidatePublicKeyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kNewPubKeyFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string new_pub_key = 2 [json_name = "newPubKey"];
  void clear_new_pub_key();
  const std::string& new_pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_pub_key();
  void set_allocated_new_pub_key(std::string* new_pub_key);
  private:
  const std::string& _internal_new_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_pub_key(const std::string& value);
  std::string* _internal_mutable_new_pub_key();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.EditCandidatePublicKeyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_pub_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CreateSwapPoolData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.CreateSwapPoolData) */ {
 public:
  inline CreateSwapPoolData() : CreateSwapPoolData(nullptr) {}
  ~CreateSwapPoolData() override;
  explicit constexpr CreateSwapPoolData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSwapPoolData(const CreateSwapPoolData& from);
  CreateSwapPoolData(CreateSwapPoolData&& from) noexcept
    : CreateSwapPoolData() {
    *this = ::std::move(from);
  }

  inline CreateSwapPoolData& operator=(const CreateSwapPoolData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSwapPoolData& operator=(CreateSwapPoolData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSwapPoolData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSwapPoolData* internal_default_instance() {
    return reinterpret_cast<const CreateSwapPoolData*>(
               &_CreateSwapPoolData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateSwapPoolData& a, CreateSwapPoolData& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSwapPoolData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSwapPoolData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSwapPoolData* New() const final {
    return new CreateSwapPoolData();
  }

  CreateSwapPoolData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSwapPoolData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSwapPoolData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSwapPoolData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSwapPoolData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.CreateSwapPoolData";
  }
  protected:
  explicit CreateSwapPoolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolume0FieldNumber = 3,
    kVolume1FieldNumber = 4,
    kCoin0FieldNumber = 1,
    kCoin1FieldNumber = 2,
  };
  // string volume0 = 3 [json_name = "volume0"];
  void clear_volume0();
  const std::string& volume0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume0();
  PROTOBUF_MUST_USE_RESULT std::string* release_volume0();
  void set_allocated_volume0(std::string* volume0);
  private:
  const std::string& _internal_volume0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume0(const std::string& value);
  std::string* _internal_mutable_volume0();
  public:

  // string volume1 = 4 [json_name = "volume1"];
  void clear_volume1();
  const std::string& volume1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume1();
  PROTOBUF_MUST_USE_RESULT std::string* release_volume1();
  void set_allocated_volume1(std::string* volume1);
  private:
  const std::string& _internal_volume1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume1(const std::string& value);
  std::string* _internal_mutable_volume1();
  public:

  // .api_pb.Coin coin0 = 1 [json_name = "coin0"];
  bool has_coin0() const;
  private:
  bool _internal_has_coin0() const;
  public:
  void clear_coin0();
  const ::api_pb::Coin& coin0() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin0();
  ::api_pb::Coin* mutable_coin0();
  void set_allocated_coin0(::api_pb::Coin* coin0);
  private:
  const ::api_pb::Coin& _internal_coin0() const;
  ::api_pb::Coin* _internal_mutable_coin0();
  public:
  void unsafe_arena_set_allocated_coin0(
      ::api_pb::Coin* coin0);
  ::api_pb::Coin* unsafe_arena_release_coin0();

  // .api_pb.Coin coin1 = 2 [json_name = "coin1"];
  bool has_coin1() const;
  private:
  bool _internal_has_coin1() const;
  public:
  void clear_coin1();
  const ::api_pb::Coin& coin1() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin1();
  ::api_pb::Coin* mutable_coin1();
  void set_allocated_coin1(::api_pb::Coin* coin1);
  private:
  const ::api_pb::Coin& _internal_coin1() const;
  ::api_pb::Coin* _internal_mutable_coin1();
  public:
  void unsafe_arena_set_allocated_coin1(
      ::api_pb::Coin* coin1);
  ::api_pb::Coin* unsafe_arena_release_coin1();

  // @@protoc_insertion_point(class_scope:api_pb.CreateSwapPoolData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume0_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume1_;
  ::api_pb::Coin* coin0_;
  ::api_pb::Coin* coin1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class AddLiquidityData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.AddLiquidityData) */ {
 public:
  inline AddLiquidityData() : AddLiquidityData(nullptr) {}
  ~AddLiquidityData() override;
  explicit constexpr AddLiquidityData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLiquidityData(const AddLiquidityData& from);
  AddLiquidityData(AddLiquidityData&& from) noexcept
    : AddLiquidityData() {
    *this = ::std::move(from);
  }

  inline AddLiquidityData& operator=(const AddLiquidityData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLiquidityData& operator=(AddLiquidityData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLiquidityData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLiquidityData* internal_default_instance() {
    return reinterpret_cast<const AddLiquidityData*>(
               &_AddLiquidityData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AddLiquidityData& a, AddLiquidityData& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLiquidityData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLiquidityData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddLiquidityData* New() const final {
    return new AddLiquidityData();
  }

  AddLiquidityData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddLiquidityData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLiquidityData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddLiquidityData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLiquidityData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.AddLiquidityData";
  }
  protected:
  explicit AddLiquidityData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolume0FieldNumber = 3,
    kMaximumVolume1FieldNumber = 4,
    kCoin0FieldNumber = 1,
    kCoin1FieldNumber = 2,
  };
  // string volume0 = 3 [json_name = "volume0"];
  void clear_volume0();
  const std::string& volume0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume0();
  PROTOBUF_MUST_USE_RESULT std::string* release_volume0();
  void set_allocated_volume0(std::string* volume0);
  private:
  const std::string& _internal_volume0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume0(const std::string& value);
  std::string* _internal_mutable_volume0();
  public:

  // string maximum_volume1 = 4 [json_name = "maximumVolume1"];
  void clear_maximum_volume1();
  const std::string& maximum_volume1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maximum_volume1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maximum_volume1();
  PROTOBUF_MUST_USE_RESULT std::string* release_maximum_volume1();
  void set_allocated_maximum_volume1(std::string* maximum_volume1);
  private:
  const std::string& _internal_maximum_volume1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maximum_volume1(const std::string& value);
  std::string* _internal_mutable_maximum_volume1();
  public:

  // .api_pb.Coin coin0 = 1 [json_name = "coin0"];
  bool has_coin0() const;
  private:
  bool _internal_has_coin0() const;
  public:
  void clear_coin0();
  const ::api_pb::Coin& coin0() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin0();
  ::api_pb::Coin* mutable_coin0();
  void set_allocated_coin0(::api_pb::Coin* coin0);
  private:
  const ::api_pb::Coin& _internal_coin0() const;
  ::api_pb::Coin* _internal_mutable_coin0();
  public:
  void unsafe_arena_set_allocated_coin0(
      ::api_pb::Coin* coin0);
  ::api_pb::Coin* unsafe_arena_release_coin0();

  // .api_pb.Coin coin1 = 2 [json_name = "coin1"];
  bool has_coin1() const;
  private:
  bool _internal_has_coin1() const;
  public:
  void clear_coin1();
  const ::api_pb::Coin& coin1() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin1();
  ::api_pb::Coin* mutable_coin1();
  void set_allocated_coin1(::api_pb::Coin* coin1);
  private:
  const ::api_pb::Coin& _internal_coin1() const;
  ::api_pb::Coin* _internal_mutable_coin1();
  public:
  void unsafe_arena_set_allocated_coin1(
      ::api_pb::Coin* coin1);
  ::api_pb::Coin* unsafe_arena_release_coin1();

  // @@protoc_insertion_point(class_scope:api_pb.AddLiquidityData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume0_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maximum_volume1_;
  ::api_pb::Coin* coin0_;
  ::api_pb::Coin* coin1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class RemoveLiquidityData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.RemoveLiquidityData) */ {
 public:
  inline RemoveLiquidityData() : RemoveLiquidityData(nullptr) {}
  ~RemoveLiquidityData() override;
  explicit constexpr RemoveLiquidityData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveLiquidityData(const RemoveLiquidityData& from);
  RemoveLiquidityData(RemoveLiquidityData&& from) noexcept
    : RemoveLiquidityData() {
    *this = ::std::move(from);
  }

  inline RemoveLiquidityData& operator=(const RemoveLiquidityData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLiquidityData& operator=(RemoveLiquidityData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLiquidityData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveLiquidityData* internal_default_instance() {
    return reinterpret_cast<const RemoveLiquidityData*>(
               &_RemoveLiquidityData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RemoveLiquidityData& a, RemoveLiquidityData& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveLiquidityData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLiquidityData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveLiquidityData* New() const final {
    return new RemoveLiquidityData();
  }

  RemoveLiquidityData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveLiquidityData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveLiquidityData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveLiquidityData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveLiquidityData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.RemoveLiquidityData";
  }
  protected:
  explicit RemoveLiquidityData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiquidityFieldNumber = 3,
    kMinimumVolume0FieldNumber = 4,
    kMinimumVolume1FieldNumber = 5,
    kCoin0FieldNumber = 1,
    kCoin1FieldNumber = 2,
  };
  // string liquidity = 3 [json_name = "liquidity"];
  void clear_liquidity();
  const std::string& liquidity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liquidity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liquidity();
  PROTOBUF_MUST_USE_RESULT std::string* release_liquidity();
  void set_allocated_liquidity(std::string* liquidity);
  private:
  const std::string& _internal_liquidity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liquidity(const std::string& value);
  std::string* _internal_mutable_liquidity();
  public:

  // string minimum_volume0 = 4 [json_name = "minimumVolume0"];
  void clear_minimum_volume0();
  const std::string& minimum_volume0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_volume0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_volume0();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_volume0();
  void set_allocated_minimum_volume0(std::string* minimum_volume0);
  private:
  const std::string& _internal_minimum_volume0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_volume0(const std::string& value);
  std::string* _internal_mutable_minimum_volume0();
  public:

  // string minimum_volume1 = 5 [json_name = "minimumVolume1"];
  void clear_minimum_volume1();
  const std::string& minimum_volume1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_volume1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_volume1();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_volume1();
  void set_allocated_minimum_volume1(std::string* minimum_volume1);
  private:
  const std::string& _internal_minimum_volume1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_volume1(const std::string& value);
  std::string* _internal_mutable_minimum_volume1();
  public:

  // .api_pb.Coin coin0 = 1 [json_name = "coin0"];
  bool has_coin0() const;
  private:
  bool _internal_has_coin0() const;
  public:
  void clear_coin0();
  const ::api_pb::Coin& coin0() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin0();
  ::api_pb::Coin* mutable_coin0();
  void set_allocated_coin0(::api_pb::Coin* coin0);
  private:
  const ::api_pb::Coin& _internal_coin0() const;
  ::api_pb::Coin* _internal_mutable_coin0();
  public:
  void unsafe_arena_set_allocated_coin0(
      ::api_pb::Coin* coin0);
  ::api_pb::Coin* unsafe_arena_release_coin0();

  // .api_pb.Coin coin1 = 2 [json_name = "coin1"];
  bool has_coin1() const;
  private:
  bool _internal_has_coin1() const;
  public:
  void clear_coin1();
  const ::api_pb::Coin& coin1() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin1();
  ::api_pb::Coin* mutable_coin1();
  void set_allocated_coin1(::api_pb::Coin* coin1);
  private:
  const ::api_pb::Coin& _internal_coin1() const;
  ::api_pb::Coin* _internal_mutable_coin1();
  public:
  void unsafe_arena_set_allocated_coin1(
      ::api_pb::Coin* coin1);
  ::api_pb::Coin* unsafe_arena_release_coin1();

  // @@protoc_insertion_point(class_scope:api_pb.RemoveLiquidityData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_volume0_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_volume1_;
  ::api_pb::Coin* coin0_;
  ::api_pb::Coin* coin1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SellSwapPoolData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SellSwapPoolData) */ {
 public:
  inline SellSwapPoolData() : SellSwapPoolData(nullptr) {}
  ~SellSwapPoolData() override;
  explicit constexpr SellSwapPoolData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellSwapPoolData(const SellSwapPoolData& from);
  SellSwapPoolData(SellSwapPoolData&& from) noexcept
    : SellSwapPoolData() {
    *this = ::std::move(from);
  }

  inline SellSwapPoolData& operator=(const SellSwapPoolData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellSwapPoolData& operator=(SellSwapPoolData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellSwapPoolData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellSwapPoolData* internal_default_instance() {
    return reinterpret_cast<const SellSwapPoolData*>(
               &_SellSwapPoolData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SellSwapPoolData& a, SellSwapPoolData& b) {
    a.Swap(&b);
  }
  inline void Swap(SellSwapPoolData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellSwapPoolData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SellSwapPoolData* New() const final {
    return new SellSwapPoolData();
  }

  SellSwapPoolData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SellSwapPoolData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellSwapPoolData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SellSwapPoolData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellSwapPoolData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SellSwapPoolData";
  }
  protected:
  explicit SellSwapPoolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoinsFieldNumber = 1,
    kValueToSellFieldNumber = 2,
    kMinimumValueToBuyFieldNumber = 4,
  };
  // repeated .api_pb.Coin coins = 1 [json_name = "coins"];
  int coins_size() const;
  private:
  int _internal_coins_size() const;
  public:
  void clear_coins();
  ::api_pb::Coin* mutable_coins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
      mutable_coins();
  private:
  const ::api_pb::Coin& _internal_coins(int index) const;
  ::api_pb::Coin* _internal_add_coins();
  public:
  const ::api_pb::Coin& coins(int index) const;
  ::api_pb::Coin* add_coins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
      coins() const;

  // string value_to_sell = 2 [json_name = "valueToSell"];
  void clear_value_to_sell();
  const std::string& value_to_sell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_sell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_sell();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_sell();
  void set_allocated_value_to_sell(std::string* value_to_sell);
  private:
  const std::string& _internal_value_to_sell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_sell(const std::string& value);
  std::string* _internal_mutable_value_to_sell();
  public:

  // string minimum_value_to_buy = 4 [json_name = "minimumValueToBuy"];
  void clear_minimum_value_to_buy();
  const std::string& minimum_value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_value_to_buy();
  void set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy);
  private:
  const std::string& _internal_minimum_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_value_to_buy(const std::string& value);
  std::string* _internal_mutable_minimum_value_to_buy();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.SellSwapPoolData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin > coins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_sell_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_value_to_buy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SellAllSwapPoolData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.SellAllSwapPoolData) */ {
 public:
  inline SellAllSwapPoolData() : SellAllSwapPoolData(nullptr) {}
  ~SellAllSwapPoolData() override;
  explicit constexpr SellAllSwapPoolData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellAllSwapPoolData(const SellAllSwapPoolData& from);
  SellAllSwapPoolData(SellAllSwapPoolData&& from) noexcept
    : SellAllSwapPoolData() {
    *this = ::std::move(from);
  }

  inline SellAllSwapPoolData& operator=(const SellAllSwapPoolData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellAllSwapPoolData& operator=(SellAllSwapPoolData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellAllSwapPoolData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellAllSwapPoolData* internal_default_instance() {
    return reinterpret_cast<const SellAllSwapPoolData*>(
               &_SellAllSwapPoolData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SellAllSwapPoolData& a, SellAllSwapPoolData& b) {
    a.Swap(&b);
  }
  inline void Swap(SellAllSwapPoolData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellAllSwapPoolData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SellAllSwapPoolData* New() const final {
    return new SellAllSwapPoolData();
  }

  SellAllSwapPoolData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SellAllSwapPoolData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellAllSwapPoolData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SellAllSwapPoolData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellAllSwapPoolData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.SellAllSwapPoolData";
  }
  protected:
  explicit SellAllSwapPoolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoinsFieldNumber = 1,
    kMinimumValueToBuyFieldNumber = 3,
  };
  // repeated .api_pb.Coin coins = 1 [json_name = "coins"];
  int coins_size() const;
  private:
  int _internal_coins_size() const;
  public:
  void clear_coins();
  ::api_pb::Coin* mutable_coins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
      mutable_coins();
  private:
  const ::api_pb::Coin& _internal_coins(int index) const;
  ::api_pb::Coin* _internal_add_coins();
  public:
  const ::api_pb::Coin& coins(int index) const;
  ::api_pb::Coin* add_coins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
      coins() const;

  // string minimum_value_to_buy = 3 [json_name = "minimumValueToBuy"];
  void clear_minimum_value_to_buy();
  const std::string& minimum_value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_minimum_value_to_buy();
  void set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy);
  private:
  const std::string& _internal_minimum_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_value_to_buy(const std::string& value);
  std::string* _internal_mutable_minimum_value_to_buy();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.SellAllSwapPoolData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin > coins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_value_to_buy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class BuySwapPoolData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.BuySwapPoolData) */ {
 public:
  inline BuySwapPoolData() : BuySwapPoolData(nullptr) {}
  ~BuySwapPoolData() override;
  explicit constexpr BuySwapPoolData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuySwapPoolData(const BuySwapPoolData& from);
  BuySwapPoolData(BuySwapPoolData&& from) noexcept
    : BuySwapPoolData() {
    *this = ::std::move(from);
  }

  inline BuySwapPoolData& operator=(const BuySwapPoolData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuySwapPoolData& operator=(BuySwapPoolData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuySwapPoolData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuySwapPoolData* internal_default_instance() {
    return reinterpret_cast<const BuySwapPoolData*>(
               &_BuySwapPoolData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BuySwapPoolData& a, BuySwapPoolData& b) {
    a.Swap(&b);
  }
  inline void Swap(BuySwapPoolData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuySwapPoolData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuySwapPoolData* New() const final {
    return new BuySwapPoolData();
  }

  BuySwapPoolData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuySwapPoolData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuySwapPoolData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuySwapPoolData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuySwapPoolData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.BuySwapPoolData";
  }
  protected:
  explicit BuySwapPoolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoinsFieldNumber = 1,
    kValueToBuyFieldNumber = 2,
    kMaximumValueToSellFieldNumber = 4,
  };
  // repeated .api_pb.Coin coins = 1 [json_name = "coins"];
  int coins_size() const;
  private:
  int _internal_coins_size() const;
  public:
  void clear_coins();
  ::api_pb::Coin* mutable_coins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
      mutable_coins();
  private:
  const ::api_pb::Coin& _internal_coins(int index) const;
  ::api_pb::Coin* _internal_add_coins();
  public:
  const ::api_pb::Coin& coins(int index) const;
  ::api_pb::Coin* add_coins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
      coins() const;

  // string value_to_buy = 2 [json_name = "valueToBuy"];
  void clear_value_to_buy();
  const std::string& value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_buy();
  void set_allocated_value_to_buy(std::string* value_to_buy);
  private:
  const std::string& _internal_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_buy(const std::string& value);
  std::string* _internal_mutable_value_to_buy();
  public:

  // string maximum_value_to_sell = 4 [json_name = "maximumValueToSell"];
  void clear_maximum_value_to_sell();
  const std::string& maximum_value_to_sell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maximum_value_to_sell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maximum_value_to_sell();
  PROTOBUF_MUST_USE_RESULT std::string* release_maximum_value_to_sell();
  void set_allocated_maximum_value_to_sell(std::string* maximum_value_to_sell);
  private:
  const std::string& _internal_maximum_value_to_sell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maximum_value_to_sell(const std::string& value);
  std::string* _internal_mutable_maximum_value_to_sell();
  public:

  // @@protoc_insertion_point(class_scope:api_pb.BuySwapPoolData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin > coins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_buy_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maximum_value_to_sell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class EditCandidateCommission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.EditCandidateCommission) */ {
 public:
  inline EditCandidateCommission() : EditCandidateCommission(nullptr) {}
  ~EditCandidateCommission() override;
  explicit constexpr EditCandidateCommission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCandidateCommission(const EditCandidateCommission& from);
  EditCandidateCommission(EditCandidateCommission&& from) noexcept
    : EditCandidateCommission() {
    *this = ::std::move(from);
  }

  inline EditCandidateCommission& operator=(const EditCandidateCommission& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCandidateCommission& operator=(EditCandidateCommission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCandidateCommission& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCandidateCommission* internal_default_instance() {
    return reinterpret_cast<const EditCandidateCommission*>(
               &_EditCandidateCommission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EditCandidateCommission& a, EditCandidateCommission& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCandidateCommission* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCandidateCommission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditCandidateCommission* New() const final {
    return new EditCandidateCommission();
  }

  EditCandidateCommission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditCandidateCommission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCandidateCommission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCandidateCommission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCandidateCommission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.EditCandidateCommission";
  }
  protected:
  explicit EditCandidateCommission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kCommissionFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // uint64 commission = 2 [json_name = "commission"];
  void clear_commission();
  ::PROTOBUF_NAMESPACE_ID::uint64 commission() const;
  void set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_commission() const;
  void _internal_set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.EditCandidateCommission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 commission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MintTokenData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.MintTokenData) */ {
 public:
  inline MintTokenData() : MintTokenData(nullptr) {}
  ~MintTokenData() override;
  explicit constexpr MintTokenData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MintTokenData(const MintTokenData& from);
  MintTokenData(MintTokenData&& from) noexcept
    : MintTokenData() {
    *this = ::std::move(from);
  }

  inline MintTokenData& operator=(const MintTokenData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MintTokenData& operator=(MintTokenData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MintTokenData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MintTokenData* internal_default_instance() {
    return reinterpret_cast<const MintTokenData*>(
               &_MintTokenData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MintTokenData& a, MintTokenData& b) {
    a.Swap(&b);
  }
  inline void Swap(MintTokenData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MintTokenData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MintTokenData* New() const final {
    return new MintTokenData();
  }

  MintTokenData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MintTokenData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MintTokenData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MintTokenData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MintTokenData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.MintTokenData";
  }
  protected:
  explicit MintTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kCoinFieldNumber = 1,
  };
  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .api_pb.Coin coin = 1 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // @@protoc_insertion_point(class_scope:api_pb.MintTokenData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::api_pb::Coin* coin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class BurnTokenData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.BurnTokenData) */ {
 public:
  inline BurnTokenData() : BurnTokenData(nullptr) {}
  ~BurnTokenData() override;
  explicit constexpr BurnTokenData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BurnTokenData(const BurnTokenData& from);
  BurnTokenData(BurnTokenData&& from) noexcept
    : BurnTokenData() {
    *this = ::std::move(from);
  }

  inline BurnTokenData& operator=(const BurnTokenData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BurnTokenData& operator=(BurnTokenData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BurnTokenData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BurnTokenData* internal_default_instance() {
    return reinterpret_cast<const BurnTokenData*>(
               &_BurnTokenData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(BurnTokenData& a, BurnTokenData& b) {
    a.Swap(&b);
  }
  inline void Swap(BurnTokenData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BurnTokenData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BurnTokenData* New() const final {
    return new BurnTokenData();
  }

  BurnTokenData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BurnTokenData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BurnTokenData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BurnTokenData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BurnTokenData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.BurnTokenData";
  }
  protected:
  explicit BurnTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kCoinFieldNumber = 1,
  };
  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .api_pb.Coin coin = 1 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // @@protoc_insertion_point(class_scope:api_pb.BurnTokenData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::api_pb::Coin* coin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CreateTokenData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.CreateTokenData) */ {
 public:
  inline CreateTokenData() : CreateTokenData(nullptr) {}
  ~CreateTokenData() override;
  explicit constexpr CreateTokenData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTokenData(const CreateTokenData& from);
  CreateTokenData(CreateTokenData&& from) noexcept
    : CreateTokenData() {
    *this = ::std::move(from);
  }

  inline CreateTokenData& operator=(const CreateTokenData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTokenData& operator=(CreateTokenData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTokenData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTokenData* internal_default_instance() {
    return reinterpret_cast<const CreateTokenData*>(
               &_CreateTokenData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreateTokenData& a, CreateTokenData& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTokenData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTokenData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTokenData* New() const final {
    return new CreateTokenData();
  }

  CreateTokenData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTokenData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTokenData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTokenData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTokenData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.CreateTokenData";
  }
  protected:
  explicit CreateTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kInitialAmountFieldNumber = 3,
    kMaxSupplyFieldNumber = 4,
    kMintableFieldNumber = 5,
    kBurnableFieldNumber = 6,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string symbol = 2 [json_name = "symbol"];
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string initial_amount = 3 [json_name = "initialAmount"];
  void clear_initial_amount();
  const std::string& initial_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_amount();
  void set_allocated_initial_amount(std::string* initial_amount);
  private:
  const std::string& _internal_initial_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_amount(const std::string& value);
  std::string* _internal_mutable_initial_amount();
  public:

  // string max_supply = 4 [json_name = "maxSupply"];
  void clear_max_supply();
  const std::string& max_supply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_supply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_supply();
  PROTOBUF_MUST_USE_RESULT std::string* release_max_supply();
  void set_allocated_max_supply(std::string* max_supply);
  private:
  const std::string& _internal_max_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_supply(const std::string& value);
  std::string* _internal_mutable_max_supply();
  public:

  // bool mintable = 5 [json_name = "mintable"];
  void clear_mintable();
  bool mintable() const;
  void set_mintable(bool value);
  private:
  bool _internal_mintable() const;
  void _internal_set_mintable(bool value);
  public:

  // bool burnable = 6 [json_name = "burnable"];
  void clear_burnable();
  bool burnable() const;
  void set_burnable(bool value);
  private:
  bool _internal_burnable() const;
  void _internal_set_burnable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.CreateTokenData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_supply_;
  bool mintable_;
  bool burnable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class RecreateTokenData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.RecreateTokenData) */ {
 public:
  inline RecreateTokenData() : RecreateTokenData(nullptr) {}
  ~RecreateTokenData() override;
  explicit constexpr RecreateTokenData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecreateTokenData(const RecreateTokenData& from);
  RecreateTokenData(RecreateTokenData&& from) noexcept
    : RecreateTokenData() {
    *this = ::std::move(from);
  }

  inline RecreateTokenData& operator=(const RecreateTokenData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecreateTokenData& operator=(RecreateTokenData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecreateTokenData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecreateTokenData* internal_default_instance() {
    return reinterpret_cast<const RecreateTokenData*>(
               &_RecreateTokenData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RecreateTokenData& a, RecreateTokenData& b) {
    a.Swap(&b);
  }
  inline void Swap(RecreateTokenData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecreateTokenData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecreateTokenData* New() const final {
    return new RecreateTokenData();
  }

  RecreateTokenData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecreateTokenData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecreateTokenData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecreateTokenData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecreateTokenData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.RecreateTokenData";
  }
  protected:
  explicit RecreateTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kInitialAmountFieldNumber = 3,
    kMaxSupplyFieldNumber = 4,
    kMintableFieldNumber = 5,
    kBurnableFieldNumber = 6,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string symbol = 2 [json_name = "symbol"];
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string initial_amount = 3 [json_name = "initialAmount"];
  void clear_initial_amount();
  const std::string& initial_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_amount();
  void set_allocated_initial_amount(std::string* initial_amount);
  private:
  const std::string& _internal_initial_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_amount(const std::string& value);
  std::string* _internal_mutable_initial_amount();
  public:

  // string max_supply = 4 [json_name = "maxSupply"];
  void clear_max_supply();
  const std::string& max_supply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_supply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_supply();
  PROTOBUF_MUST_USE_RESULT std::string* release_max_supply();
  void set_allocated_max_supply(std::string* max_supply);
  private:
  const std::string& _internal_max_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_supply(const std::string& value);
  std::string* _internal_mutable_max_supply();
  public:

  // bool mintable = 5 [json_name = "mintable"];
  void clear_mintable();
  bool mintable() const;
  void set_mintable(bool value);
  private:
  bool _internal_mintable() const;
  void _internal_set_mintable(bool value);
  public:

  // bool burnable = 6 [json_name = "burnable"];
  void clear_burnable();
  bool burnable() const;
  void set_burnable(bool value);
  private:
  bool _internal_burnable() const;
  void _internal_set_burnable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.RecreateTokenData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_supply_;
  bool mintable_;
  bool burnable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class VoteCommissionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.VoteCommissionData) */ {
 public:
  inline VoteCommissionData() : VoteCommissionData(nullptr) {}
  ~VoteCommissionData() override;
  explicit constexpr VoteCommissionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteCommissionData(const VoteCommissionData& from);
  VoteCommissionData(VoteCommissionData&& from) noexcept
    : VoteCommissionData() {
    *this = ::std::move(from);
  }

  inline VoteCommissionData& operator=(const VoteCommissionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteCommissionData& operator=(VoteCommissionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteCommissionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteCommissionData* internal_default_instance() {
    return reinterpret_cast<const VoteCommissionData*>(
               &_VoteCommissionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VoteCommissionData& a, VoteCommissionData& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteCommissionData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteCommissionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoteCommissionData* New() const final {
    return new VoteCommissionData();
  }

  VoteCommissionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoteCommissionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteCommissionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteCommissionData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteCommissionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.VoteCommissionData";
  }
  protected:
  explicit VoteCommissionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kPayloadByteFieldNumber = 4,
    kSendFieldNumber = 5,
    kCreateTicker3FieldNumber = 7,
    kCreateTicker4FieldNumber = 8,
    kCreateTicker5FieldNumber = 9,
    kCreateTicker6FieldNumber = 10,
    kCreateTicker710FieldNumber = 11,
    kDeclareCandidacyFieldNumber = 13,
    kDelegateFieldNumber = 14,
    kUnbondFieldNumber = 15,
    kRedeemCheckFieldNumber = 16,
    kCreateMultisigFieldNumber = 18,
    kEditCandidateFieldNumber = 20,
    kSetHaltBlockFieldNumber = 21,
    kEditTickerOwnerFieldNumber = 22,
    kEditMultisigFieldNumber = 23,
    kEditCandidatePublicKeyFieldNumber = 25,
    kEditCandidateCommissionFieldNumber = 28,
    kVoteCommissionFieldNumber = 31,
    kVoteUpdateFieldNumber = 32,
    kCreateCoinFieldNumber = 34,
    kCreateTokenFieldNumber = 35,
    kRecreateCoinFieldNumber = 36,
    kRecreateTokenFieldNumber = 37,
    kBuyBancorFieldNumber = 38,
    kSellBancorFieldNumber = 39,
    kSellAllBancorFieldNumber = 40,
    kBuyPoolBaseFieldNumber = 41,
    kSellPoolBaseFieldNumber = 42,
    kSellAllPoolBaseFieldNumber = 43,
    kSetCandidateOnFieldNumber = 44,
    kSetCandidateOffFieldNumber = 45,
    kMintTokenFieldNumber = 46,
    kBurnTokenFieldNumber = 47,
    kCreateSwapPoolFieldNumber = 48,
    kAddLiquidityFieldNumber = 49,
    kRemoveLiquidityFieldNumber = 50,
    kMultisendBaseFieldNumber = 51,
    kMultisendDeltaFieldNumber = 52,
    kBuyPoolDeltaFieldNumber = 53,
    kSellPoolDeltaFieldNumber = 54,
    kSellAllPoolDeltaFieldNumber = 55,
    kFailedTxFieldNumber = 56,
    kAddLimitOrderFieldNumber = 57,
    kRemoveLimitOrderFieldNumber = 58,
    kCoinFieldNumber = 3,
    kHeightFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string payload_byte = 4 [json_name = "payloadByte"];
  void clear_payload_byte();
  const std::string& payload_byte() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_byte(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_byte();
  PROTOBUF_MUST_USE_RESULT std::string* release_payload_byte();
  void set_allocated_payload_byte(std::string* payload_byte);
  private:
  const std::string& _internal_payload_byte() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_byte(const std::string& value);
  std::string* _internal_mutable_payload_byte();
  public:

  // string send = 5 [json_name = "send"];
  void clear_send();
  const std::string& send() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_send(ArgT0&& arg0, ArgT... args);
  std::string* mutable_send();
  PROTOBUF_MUST_USE_RESULT std::string* release_send();
  void set_allocated_send(std::string* send);
  private:
  const std::string& _internal_send() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_send(const std::string& value);
  std::string* _internal_mutable_send();
  public:

  // string create_ticker3 = 7 [json_name = "createTicker3"];
  void clear_create_ticker3();
  const std::string& create_ticker3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_ticker3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_ticker3();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_ticker3();
  void set_allocated_create_ticker3(std::string* create_ticker3);
  private:
  const std::string& _internal_create_ticker3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_ticker3(const std::string& value);
  std::string* _internal_mutable_create_ticker3();
  public:

  // string create_ticker4 = 8 [json_name = "createTicker4"];
  void clear_create_ticker4();
  const std::string& create_ticker4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_ticker4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_ticker4();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_ticker4();
  void set_allocated_create_ticker4(std::string* create_ticker4);
  private:
  const std::string& _internal_create_ticker4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_ticker4(const std::string& value);
  std::string* _internal_mutable_create_ticker4();
  public:

  // string create_ticker5 = 9 [json_name = "createTicker5"];
  void clear_create_ticker5();
  const std::string& create_ticker5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_ticker5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_ticker5();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_ticker5();
  void set_allocated_create_ticker5(std::string* create_ticker5);
  private:
  const std::string& _internal_create_ticker5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_ticker5(const std::string& value);
  std::string* _internal_mutable_create_ticker5();
  public:

  // string create_ticker6 = 10 [json_name = "createTicker6"];
  void clear_create_ticker6();
  const std::string& create_ticker6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_ticker6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_ticker6();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_ticker6();
  void set_allocated_create_ticker6(std::string* create_ticker6);
  private:
  const std::string& _internal_create_ticker6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_ticker6(const std::string& value);
  std::string* _internal_mutable_create_ticker6();
  public:

  // string create_ticker7_10 = 11 [json_name = "createTicker710"];
  void clear_create_ticker7_10();
  const std::string& create_ticker7_10() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_ticker7_10(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_ticker7_10();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_ticker7_10();
  void set_allocated_create_ticker7_10(std::string* create_ticker7_10);
  private:
  const std::string& _internal_create_ticker7_10() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_ticker7_10(const std::string& value);
  std::string* _internal_mutable_create_ticker7_10();
  public:

  // string declare_candidacy = 13 [json_name = "declareCandidacy"];
  void clear_declare_candidacy();
  const std::string& declare_candidacy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_declare_candidacy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_declare_candidacy();
  PROTOBUF_MUST_USE_RESULT std::string* release_declare_candidacy();
  void set_allocated_declare_candidacy(std::string* declare_candidacy);
  private:
  const std::string& _internal_declare_candidacy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_declare_candidacy(const std::string& value);
  std::string* _internal_mutable_declare_candidacy();
  public:

  // string delegate = 14 [json_name = "delegate"];
  void clear_delegate();
  const std::string& delegate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delegate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delegate();
  PROTOBUF_MUST_USE_RESULT std::string* release_delegate();
  void set_allocated_delegate(std::string* delegate);
  private:
  const std::string& _internal_delegate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegate(const std::string& value);
  std::string* _internal_mutable_delegate();
  public:

  // string unbond = 15 [json_name = "unbond"];
  void clear_unbond();
  const std::string& unbond() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unbond(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unbond();
  PROTOBUF_MUST_USE_RESULT std::string* release_unbond();
  void set_allocated_unbond(std::string* unbond);
  private:
  const std::string& _internal_unbond() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unbond(const std::string& value);
  std::string* _internal_mutable_unbond();
  public:

  // string redeem_check = 16 [json_name = "redeemCheck"];
  void clear_redeem_check();
  const std::string& redeem_check() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redeem_check(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redeem_check();
  PROTOBUF_MUST_USE_RESULT std::string* release_redeem_check();
  void set_allocated_redeem_check(std::string* redeem_check);
  private:
  const std::string& _internal_redeem_check() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redeem_check(const std::string& value);
  std::string* _internal_mutable_redeem_check();
  public:

  // string create_multisig = 18 [json_name = "createMultisig"];
  void clear_create_multisig();
  const std::string& create_multisig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_multisig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_multisig();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_multisig();
  void set_allocated_create_multisig(std::string* create_multisig);
  private:
  const std::string& _internal_create_multisig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_multisig(const std::string& value);
  std::string* _internal_mutable_create_multisig();
  public:

  // string edit_candidate = 20 [json_name = "editCandidate"];
  void clear_edit_candidate();
  const std::string& edit_candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_candidate();
  PROTOBUF_MUST_USE_RESULT std::string* release_edit_candidate();
  void set_allocated_edit_candidate(std::string* edit_candidate);
  private:
  const std::string& _internal_edit_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_candidate(const std::string& value);
  std::string* _internal_mutable_edit_candidate();
  public:

  // string set_halt_block = 21 [json_name = "setHaltBlock"];
  void clear_set_halt_block();
  const std::string& set_halt_block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_halt_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_halt_block();
  PROTOBUF_MUST_USE_RESULT std::string* release_set_halt_block();
  void set_allocated_set_halt_block(std::string* set_halt_block);
  private:
  const std::string& _internal_set_halt_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_halt_block(const std::string& value);
  std::string* _internal_mutable_set_halt_block();
  public:

  // string edit_ticker_owner = 22 [json_name = "editTickerOwner"];
  void clear_edit_ticker_owner();
  const std::string& edit_ticker_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_ticker_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_ticker_owner();
  PROTOBUF_MUST_USE_RESULT std::string* release_edit_ticker_owner();
  void set_allocated_edit_ticker_owner(std::string* edit_ticker_owner);
  private:
  const std::string& _internal_edit_ticker_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_ticker_owner(const std::string& value);
  std::string* _internal_mutable_edit_ticker_owner();
  public:

  // string edit_multisig = 23 [json_name = "editMultisig"];
  void clear_edit_multisig();
  const std::string& edit_multisig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_multisig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_multisig();
  PROTOBUF_MUST_USE_RESULT std::string* release_edit_multisig();
  void set_allocated_edit_multisig(std::string* edit_multisig);
  private:
  const std::string& _internal_edit_multisig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_multisig(const std::string& value);
  std::string* _internal_mutable_edit_multisig();
  public:

  // string edit_candidate_public_key = 25 [json_name = "editCandidatePublicKey"];
  void clear_edit_candidate_public_key();
  const std::string& edit_candidate_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_candidate_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_candidate_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_edit_candidate_public_key();
  void set_allocated_edit_candidate_public_key(std::string* edit_candidate_public_key);
  private:
  const std::string& _internal_edit_candidate_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_candidate_public_key(const std::string& value);
  std::string* _internal_mutable_edit_candidate_public_key();
  public:

  // string edit_candidate_commission = 28 [json_name = "editCandidateCommission"];
  void clear_edit_candidate_commission();
  const std::string& edit_candidate_commission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_candidate_commission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_candidate_commission();
  PROTOBUF_MUST_USE_RESULT std::string* release_edit_candidate_commission();
  void set_allocated_edit_candidate_commission(std::string* edit_candidate_commission);
  private:
  const std::string& _internal_edit_candidate_commission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_candidate_commission(const std::string& value);
  std::string* _internal_mutable_edit_candidate_commission();
  public:

  // string vote_commission = 31 [json_name = "voteCommission"];
  void clear_vote_commission();
  const std::string& vote_commission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vote_commission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vote_commission();
  PROTOBUF_MUST_USE_RESULT std::string* release_vote_commission();
  void set_allocated_vote_commission(std::string* vote_commission);
  private:
  const std::string& _internal_vote_commission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_commission(const std::string& value);
  std::string* _internal_mutable_vote_commission();
  public:

  // string vote_update = 32 [json_name = "voteUpdate"];
  void clear_vote_update();
  const std::string& vote_update() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vote_update(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vote_update();
  PROTOBUF_MUST_USE_RESULT std::string* release_vote_update();
  void set_allocated_vote_update(std::string* vote_update);
  private:
  const std::string& _internal_vote_update() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_update(const std::string& value);
  std::string* _internal_mutable_vote_update();
  public:

  // string create_coin = 34 [json_name = "createCoin"];
  void clear_create_coin();
  const std::string& create_coin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_coin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_coin();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_coin();
  void set_allocated_create_coin(std::string* create_coin);
  private:
  const std::string& _internal_create_coin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_coin(const std::string& value);
  std::string* _internal_mutable_create_coin();
  public:

  // string create_token = 35 [json_name = "createToken"];
  void clear_create_token();
  const std::string& create_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_token();
  void set_allocated_create_token(std::string* create_token);
  private:
  const std::string& _internal_create_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_token(const std::string& value);
  std::string* _internal_mutable_create_token();
  public:

  // string recreate_coin = 36 [json_name = "recreateCoin"];
  void clear_recreate_coin();
  const std::string& recreate_coin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recreate_coin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recreate_coin();
  PROTOBUF_MUST_USE_RESULT std::string* release_recreate_coin();
  void set_allocated_recreate_coin(std::string* recreate_coin);
  private:
  const std::string& _internal_recreate_coin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recreate_coin(const std::string& value);
  std::string* _internal_mutable_recreate_coin();
  public:

  // string recreate_token = 37 [json_name = "recreateToken"];
  void clear_recreate_token();
  const std::string& recreate_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recreate_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recreate_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_recreate_token();
  void set_allocated_recreate_token(std::string* recreate_token);
  private:
  const std::string& _internal_recreate_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recreate_token(const std::string& value);
  std::string* _internal_mutable_recreate_token();
  public:

  // string buy_bancor = 38 [json_name = "buyBancor"];
  void clear_buy_bancor();
  const std::string& buy_bancor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_bancor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_bancor();
  PROTOBUF_MUST_USE_RESULT std::string* release_buy_bancor();
  void set_allocated_buy_bancor(std::string* buy_bancor);
  private:
  const std::string& _internal_buy_bancor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_bancor(const std::string& value);
  std::string* _internal_mutable_buy_bancor();
  public:

  // string sell_bancor = 39 [json_name = "sellBancor"];
  void clear_sell_bancor();
  const std::string& sell_bancor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_bancor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_bancor();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_bancor();
  void set_allocated_sell_bancor(std::string* sell_bancor);
  private:
  const std::string& _internal_sell_bancor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_bancor(const std::string& value);
  std::string* _internal_mutable_sell_bancor();
  public:

  // string sell_all_bancor = 40 [json_name = "sellAllBancor"];
  void clear_sell_all_bancor();
  const std::string& sell_all_bancor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_all_bancor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_all_bancor();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_all_bancor();
  void set_allocated_sell_all_bancor(std::string* sell_all_bancor);
  private:
  const std::string& _internal_sell_all_bancor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_all_bancor(const std::string& value);
  std::string* _internal_mutable_sell_all_bancor();
  public:

  // string buy_pool_base = 41 [json_name = "buyPoolBase"];
  void clear_buy_pool_base();
  const std::string& buy_pool_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_pool_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_pool_base();
  PROTOBUF_MUST_USE_RESULT std::string* release_buy_pool_base();
  void set_allocated_buy_pool_base(std::string* buy_pool_base);
  private:
  const std::string& _internal_buy_pool_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_pool_base(const std::string& value);
  std::string* _internal_mutable_buy_pool_base();
  public:

  // string sell_pool_base = 42 [json_name = "sellPoolBase"];
  void clear_sell_pool_base();
  const std::string& sell_pool_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_pool_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_pool_base();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_pool_base();
  void set_allocated_sell_pool_base(std::string* sell_pool_base);
  private:
  const std::string& _internal_sell_pool_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_pool_base(const std::string& value);
  std::string* _internal_mutable_sell_pool_base();
  public:

  // string sell_all_pool_base = 43 [json_name = "sellAllPoolBase"];
  void clear_sell_all_pool_base();
  const std::string& sell_all_pool_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_all_pool_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_all_pool_base();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_all_pool_base();
  void set_allocated_sell_all_pool_base(std::string* sell_all_pool_base);
  private:
  const std::string& _internal_sell_all_pool_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_all_pool_base(const std::string& value);
  std::string* _internal_mutable_sell_all_pool_base();
  public:

  // string set_candidate_on = 44 [json_name = "setCandidateOn"];
  void clear_set_candidate_on();
  const std::string& set_candidate_on() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_candidate_on(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_candidate_on();
  PROTOBUF_MUST_USE_RESULT std::string* release_set_candidate_on();
  void set_allocated_set_candidate_on(std::string* set_candidate_on);
  private:
  const std::string& _internal_set_candidate_on() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_candidate_on(const std::string& value);
  std::string* _internal_mutable_set_candidate_on();
  public:

  // string set_candidate_off = 45 [json_name = "setCandidateOff"];
  void clear_set_candidate_off();
  const std::string& set_candidate_off() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_candidate_off(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_candidate_off();
  PROTOBUF_MUST_USE_RESULT std::string* release_set_candidate_off();
  void set_allocated_set_candidate_off(std::string* set_candidate_off);
  private:
  const std::string& _internal_set_candidate_off() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_candidate_off(const std::string& value);
  std::string* _internal_mutable_set_candidate_off();
  public:

  // string mint_token = 46 [json_name = "mintToken"];
  void clear_mint_token();
  const std::string& mint_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mint_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mint_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_mint_token();
  void set_allocated_mint_token(std::string* mint_token);
  private:
  const std::string& _internal_mint_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mint_token(const std::string& value);
  std::string* _internal_mutable_mint_token();
  public:

  // string burn_token = 47 [json_name = "burnToken"];
  void clear_burn_token();
  const std::string& burn_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_burn_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_burn_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_burn_token();
  void set_allocated_burn_token(std::string* burn_token);
  private:
  const std::string& _internal_burn_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_burn_token(const std::string& value);
  std::string* _internal_mutable_burn_token();
  public:

  // string create_swap_pool = 48 [json_name = "createSwapPool"];
  void clear_create_swap_pool();
  const std::string& create_swap_pool() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_swap_pool(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_swap_pool();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_swap_pool();
  void set_allocated_create_swap_pool(std::string* create_swap_pool);
  private:
  const std::string& _internal_create_swap_pool() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_swap_pool(const std::string& value);
  std::string* _internal_mutable_create_swap_pool();
  public:

  // string add_liquidity = 49 [json_name = "addLiquidity"];
  void clear_add_liquidity();
  const std::string& add_liquidity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_add_liquidity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_add_liquidity();
  PROTOBUF_MUST_USE_RESULT std::string* release_add_liquidity();
  void set_allocated_add_liquidity(std::string* add_liquidity);
  private:
  const std::string& _internal_add_liquidity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_add_liquidity(const std::string& value);
  std::string* _internal_mutable_add_liquidity();
  public:

  // string remove_liquidity = 50 [json_name = "removeLiquidity"];
  void clear_remove_liquidity();
  const std::string& remove_liquidity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remove_liquidity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remove_liquidity();
  PROTOBUF_MUST_USE_RESULT std::string* release_remove_liquidity();
  void set_allocated_remove_liquidity(std::string* remove_liquidity);
  private:
  const std::string& _internal_remove_liquidity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remove_liquidity(const std::string& value);
  std::string* _internal_mutable_remove_liquidity();
  public:

  // string multisend_base = 51 [json_name = "multisendBase"];
  void clear_multisend_base();
  const std::string& multisend_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_multisend_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_multisend_base();
  PROTOBUF_MUST_USE_RESULT std::string* release_multisend_base();
  void set_allocated_multisend_base(std::string* multisend_base);
  private:
  const std::string& _internal_multisend_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_multisend_base(const std::string& value);
  std::string* _internal_mutable_multisend_base();
  public:

  // string multisend_delta = 52 [json_name = "multisendDelta"];
  void clear_multisend_delta();
  const std::string& multisend_delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_multisend_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_multisend_delta();
  PROTOBUF_MUST_USE_RESULT std::string* release_multisend_delta();
  void set_allocated_multisend_delta(std::string* multisend_delta);
  private:
  const std::string& _internal_multisend_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_multisend_delta(const std::string& value);
  std::string* _internal_mutable_multisend_delta();
  public:

  // string buy_pool_delta = 53 [json_name = "buyPoolDelta"];
  void clear_buy_pool_delta();
  const std::string& buy_pool_delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_pool_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_pool_delta();
  PROTOBUF_MUST_USE_RESULT std::string* release_buy_pool_delta();
  void set_allocated_buy_pool_delta(std::string* buy_pool_delta);
  private:
  const std::string& _internal_buy_pool_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_pool_delta(const std::string& value);
  std::string* _internal_mutable_buy_pool_delta();
  public:

  // string sell_pool_delta = 54 [json_name = "sellPoolDelta"];
  void clear_sell_pool_delta();
  const std::string& sell_pool_delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_pool_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_pool_delta();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_pool_delta();
  void set_allocated_sell_pool_delta(std::string* sell_pool_delta);
  private:
  const std::string& _internal_sell_pool_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_pool_delta(const std::string& value);
  std::string* _internal_mutable_sell_pool_delta();
  public:

  // string sell_all_pool_delta = 55 [json_name = "sellAllPoolDelta"];
  void clear_sell_all_pool_delta();
  const std::string& sell_all_pool_delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_all_pool_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_all_pool_delta();
  PROTOBUF_MUST_USE_RESULT std::string* release_sell_all_pool_delta();
  void set_allocated_sell_all_pool_delta(std::string* sell_all_pool_delta);
  private:
  const std::string& _internal_sell_all_pool_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_all_pool_delta(const std::string& value);
  std::string* _internal_mutable_sell_all_pool_delta();
  public:

  // string failed_tx = 56 [json_name = "failedTx"];
  void clear_failed_tx();
  const std::string& failed_tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failed_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failed_tx();
  PROTOBUF_MUST_USE_RESULT std::string* release_failed_tx();
  void set_allocated_failed_tx(std::string* failed_tx);
  private:
  const std::string& _internal_failed_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failed_tx(const std::string& value);
  std::string* _internal_mutable_failed_tx();
  public:

  // string add_limit_order = 57 [json_name = "addLimitOrder"];
  void clear_add_limit_order();
  const std::string& add_limit_order() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_add_limit_order(ArgT0&& arg0, ArgT... args);
  std::string* mutable_add_limit_order();
  PROTOBUF_MUST_USE_RESULT std::string* release_add_limit_order();
  void set_allocated_add_limit_order(std::string* add_limit_order);
  private:
  const std::string& _internal_add_limit_order() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_add_limit_order(const std::string& value);
  std::string* _internal_mutable_add_limit_order();
  public:

  // string remove_limit_order = 58 [json_name = "removeLimitOrder"];
  void clear_remove_limit_order();
  const std::string& remove_limit_order() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remove_limit_order(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remove_limit_order();
  PROTOBUF_MUST_USE_RESULT std::string* release_remove_limit_order();
  void set_allocated_remove_limit_order(std::string* remove_limit_order);
  private:
  const std::string& _internal_remove_limit_order() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remove_limit_order(const std::string& value);
  std::string* _internal_mutable_remove_limit_order();
  public:

  // .api_pb.Coin coin = 3 [json_name = "coin"];
  bool has_coin() const;
  private:
  bool _internal_has_coin() const;
  public:
  void clear_coin();
  const ::api_pb::Coin& coin() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin();
  ::api_pb::Coin* mutable_coin();
  void set_allocated_coin(::api_pb::Coin* coin);
  private:
  const ::api_pb::Coin& _internal_coin() const;
  ::api_pb::Coin* _internal_mutable_coin();
  public:
  void unsafe_arena_set_allocated_coin(
      ::api_pb::Coin* coin);
  ::api_pb::Coin* unsafe_arena_release_coin();

  // uint64 height = 2 [json_name = "height"];
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.VoteCommissionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_byte_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr send_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_ticker3_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_ticker4_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_ticker5_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_ticker6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_ticker7_10_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr declare_candidacy_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unbond_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redeem_check_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_multisig_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_candidate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_halt_block_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_ticker_owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_multisig_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_candidate_public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_candidate_commission_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_commission_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_update_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_coin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recreate_coin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recreate_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_bancor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_bancor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_all_bancor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_pool_base_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_pool_base_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_all_pool_base_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_candidate_on_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_candidate_off_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mint_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr burn_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_swap_pool_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr add_liquidity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remove_liquidity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multisend_base_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multisend_delta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_pool_delta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_pool_delta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_all_pool_delta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failed_tx_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr add_limit_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remove_limit_order_;
  ::api_pb::Coin* coin_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class VoteUpdateData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.VoteUpdateData) */ {
 public:
  inline VoteUpdateData() : VoteUpdateData(nullptr) {}
  ~VoteUpdateData() override;
  explicit constexpr VoteUpdateData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteUpdateData(const VoteUpdateData& from);
  VoteUpdateData(VoteUpdateData&& from) noexcept
    : VoteUpdateData() {
    *this = ::std::move(from);
  }

  inline VoteUpdateData& operator=(const VoteUpdateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteUpdateData& operator=(VoteUpdateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteUpdateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteUpdateData* internal_default_instance() {
    return reinterpret_cast<const VoteUpdateData*>(
               &_VoteUpdateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(VoteUpdateData& a, VoteUpdateData& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteUpdateData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteUpdateData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoteUpdateData* New() const final {
    return new VoteUpdateData();
  }

  VoteUpdateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoteUpdateData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteUpdateData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteUpdateData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteUpdateData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.VoteUpdateData";
  }
  protected:
  explicit VoteUpdateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kVersionFieldNumber = 3,
    kHeightFieldNumber = 2,
  };
  // string pub_key = 1 [json_name = "pubKey"];
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string version = 3 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 height = 2 [json_name = "height"];
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.VoteUpdateData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class AddLimitOrderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.AddLimitOrderData) */ {
 public:
  inline AddLimitOrderData() : AddLimitOrderData(nullptr) {}
  ~AddLimitOrderData() override;
  explicit constexpr AddLimitOrderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLimitOrderData(const AddLimitOrderData& from);
  AddLimitOrderData(AddLimitOrderData&& from) noexcept
    : AddLimitOrderData() {
    *this = ::std::move(from);
  }

  inline AddLimitOrderData& operator=(const AddLimitOrderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLimitOrderData& operator=(AddLimitOrderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLimitOrderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLimitOrderData* internal_default_instance() {
    return reinterpret_cast<const AddLimitOrderData*>(
               &_AddLimitOrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AddLimitOrderData& a, AddLimitOrderData& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLimitOrderData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLimitOrderData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddLimitOrderData* New() const final {
    return new AddLimitOrderData();
  }

  AddLimitOrderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddLimitOrderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLimitOrderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddLimitOrderData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLimitOrderData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.AddLimitOrderData";
  }
  protected:
  explicit AddLimitOrderData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueToSellFieldNumber = 2,
    kValueToBuyFieldNumber = 4,
    kCoinToSellFieldNumber = 1,
    kCoinToBuyFieldNumber = 3,
  };
  // string value_to_sell = 2 [json_name = "valueToSell"];
  void clear_value_to_sell();
  const std::string& value_to_sell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_sell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_sell();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_sell();
  void set_allocated_value_to_sell(std::string* value_to_sell);
  private:
  const std::string& _internal_value_to_sell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_sell(const std::string& value);
  std::string* _internal_mutable_value_to_sell();
  public:

  // string value_to_buy = 4 [json_name = "valueToBuy"];
  void clear_value_to_buy();
  const std::string& value_to_buy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_to_buy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_to_buy();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_to_buy();
  void set_allocated_value_to_buy(std::string* value_to_buy);
  private:
  const std::string& _internal_value_to_buy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_to_buy(const std::string& value);
  std::string* _internal_mutable_value_to_buy();
  public:

  // .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
  bool has_coin_to_sell() const;
  private:
  bool _internal_has_coin_to_sell() const;
  public:
  void clear_coin_to_sell();
  const ::api_pb::Coin& coin_to_sell() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_sell();
  ::api_pb::Coin* mutable_coin_to_sell();
  void set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell);
  private:
  const ::api_pb::Coin& _internal_coin_to_sell() const;
  ::api_pb::Coin* _internal_mutable_coin_to_sell();
  public:
  void unsafe_arena_set_allocated_coin_to_sell(
      ::api_pb::Coin* coin_to_sell);
  ::api_pb::Coin* unsafe_arena_release_coin_to_sell();

  // .api_pb.Coin coin_to_buy = 3 [json_name = "coinToBuy"];
  bool has_coin_to_buy() const;
  private:
  bool _internal_has_coin_to_buy() const;
  public:
  void clear_coin_to_buy();
  const ::api_pb::Coin& coin_to_buy() const;
  PROTOBUF_MUST_USE_RESULT ::api_pb::Coin* release_coin_to_buy();
  ::api_pb::Coin* mutable_coin_to_buy();
  void set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy);
  private:
  const ::api_pb::Coin& _internal_coin_to_buy() const;
  ::api_pb::Coin* _internal_mutable_coin_to_buy();
  public:
  void unsafe_arena_set_allocated_coin_to_buy(
      ::api_pb::Coin* coin_to_buy);
  ::api_pb::Coin* unsafe_arena_release_coin_to_buy();

  // @@protoc_insertion_point(class_scope:api_pb.AddLimitOrderData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_sell_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_to_buy_;
  ::api_pb::Coin* coin_to_sell_;
  ::api_pb::Coin* coin_to_buy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class RemoveLimitOrderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api_pb.RemoveLimitOrderData) */ {
 public:
  inline RemoveLimitOrderData() : RemoveLimitOrderData(nullptr) {}
  ~RemoveLimitOrderData() override;
  explicit constexpr RemoveLimitOrderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveLimitOrderData(const RemoveLimitOrderData& from);
  RemoveLimitOrderData(RemoveLimitOrderData&& from) noexcept
    : RemoveLimitOrderData() {
    *this = ::std::move(from);
  }

  inline RemoveLimitOrderData& operator=(const RemoveLimitOrderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLimitOrderData& operator=(RemoveLimitOrderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLimitOrderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveLimitOrderData* internal_default_instance() {
    return reinterpret_cast<const RemoveLimitOrderData*>(
               &_RemoveLimitOrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RemoveLimitOrderData& a, RemoveLimitOrderData& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveLimitOrderData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLimitOrderData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveLimitOrderData* New() const final {
    return new RemoveLimitOrderData();
  }

  RemoveLimitOrderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveLimitOrderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveLimitOrderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveLimitOrderData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveLimitOrderData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api_pb.RemoveLimitOrderData";
  }
  protected:
  explicit RemoveLimitOrderData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:api_pb.RemoveLimitOrderData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_data_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SendData

// .api_pb.Coin coin = 1 [json_name = "coin"];
inline bool SendData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool SendData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& SendData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& SendData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.SendData.coin)
  return _internal_coin();
}
inline void SendData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.SendData.coin)
}
inline ::api_pb::Coin* SendData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* SendData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.SendData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* SendData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* SendData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.SendData.coin)
  return _msg;
}
inline void SendData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.SendData.coin)
}

// string to = 2 [json_name = "to"];
inline void SendData::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& SendData::to() const {
  // @@protoc_insertion_point(field_get:api_pb.SendData.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendData::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SendData.to)
}
inline std::string* SendData::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:api_pb.SendData.to)
  return _s;
}
inline const std::string& SendData::_internal_to() const {
  return to_.Get();
}
inline void SendData::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendData::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendData::release_to() {
  // @@protoc_insertion_point(field_release:api_pb.SendData.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendData::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SendData.to)
}

// string value = 3 [json_name = "value"];
inline void SendData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& SendData::value() const {
  // @@protoc_insertion_point(field_get:api_pb.SendData.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SendData.value)
}
inline std::string* SendData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api_pb.SendData.value)
  return _s;
}
inline const std::string& SendData::_internal_value() const {
  return value_.Get();
}
inline void SendData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendData::release_value() {
  // @@protoc_insertion_point(field_release:api_pb.SendData.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SendData.value)
}

// -------------------------------------------------------------------

// SellCoinData

// .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
inline bool SellCoinData::_internal_has_coin_to_sell() const {
  return this != internal_default_instance() && coin_to_sell_ != nullptr;
}
inline bool SellCoinData::has_coin_to_sell() const {
  return _internal_has_coin_to_sell();
}
inline const ::api_pb::Coin& SellCoinData::_internal_coin_to_sell() const {
  const ::api_pb::Coin* p = coin_to_sell_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& SellCoinData::coin_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.SellCoinData.coin_to_sell)
  return _internal_coin_to_sell();
}
inline void SellCoinData::unsafe_arena_set_allocated_coin_to_sell(
    ::api_pb::Coin* coin_to_sell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  coin_to_sell_ = coin_to_sell;
  if (coin_to_sell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.SellCoinData.coin_to_sell)
}
inline ::api_pb::Coin* SellCoinData::release_coin_to_sell() {
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* SellCoinData::unsafe_arena_release_coin_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.SellCoinData.coin_to_sell)
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* SellCoinData::_internal_mutable_coin_to_sell() {
  
  if (coin_to_sell_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_sell_ = p;
  }
  return coin_to_sell_;
}
inline ::api_pb::Coin* SellCoinData::mutable_coin_to_sell() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.SellCoinData.coin_to_sell)
  return _msg;
}
inline void SellCoinData::set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  if (coin_to_sell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell));
    if (message_arena != submessage_arena) {
      coin_to_sell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_sell, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_sell_ = coin_to_sell;
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellCoinData.coin_to_sell)
}

// string value_to_sell = 2 [json_name = "valueToSell"];
inline void SellCoinData::clear_value_to_sell() {
  value_to_sell_.ClearToEmpty();
}
inline const std::string& SellCoinData::value_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.SellCoinData.value_to_sell)
  return _internal_value_to_sell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellCoinData::set_value_to_sell(ArgT0&& arg0, ArgT... args) {
 
 value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellCoinData.value_to_sell)
}
inline std::string* SellCoinData::mutable_value_to_sell() {
  std::string* _s = _internal_mutable_value_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.SellCoinData.value_to_sell)
  return _s;
}
inline const std::string& SellCoinData::_internal_value_to_sell() const {
  return value_to_sell_.Get();
}
inline void SellCoinData::_internal_set_value_to_sell(const std::string& value) {
  
  value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellCoinData::_internal_mutable_value_to_sell() {
  
  return value_to_sell_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellCoinData::release_value_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.SellCoinData.value_to_sell)
  return value_to_sell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellCoinData::set_allocated_value_to_sell(std::string* value_to_sell) {
  if (value_to_sell != nullptr) {
    
  } else {
    
  }
  value_to_sell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_sell,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellCoinData.value_to_sell)
}

// .api_pb.Coin coin_to_buy = 3 [json_name = "coinToBuy"];
inline bool SellCoinData::_internal_has_coin_to_buy() const {
  return this != internal_default_instance() && coin_to_buy_ != nullptr;
}
inline bool SellCoinData::has_coin_to_buy() const {
  return _internal_has_coin_to_buy();
}
inline const ::api_pb::Coin& SellCoinData::_internal_coin_to_buy() const {
  const ::api_pb::Coin* p = coin_to_buy_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& SellCoinData::coin_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellCoinData.coin_to_buy)
  return _internal_coin_to_buy();
}
inline void SellCoinData::unsafe_arena_set_allocated_coin_to_buy(
    ::api_pb::Coin* coin_to_buy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  coin_to_buy_ = coin_to_buy;
  if (coin_to_buy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.SellCoinData.coin_to_buy)
}
inline ::api_pb::Coin* SellCoinData::release_coin_to_buy() {
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* SellCoinData::unsafe_arena_release_coin_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellCoinData.coin_to_buy)
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* SellCoinData::_internal_mutable_coin_to_buy() {
  
  if (coin_to_buy_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_buy_ = p;
  }
  return coin_to_buy_;
}
inline ::api_pb::Coin* SellCoinData::mutable_coin_to_buy() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellCoinData.coin_to_buy)
  return _msg;
}
inline void SellCoinData::set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  if (coin_to_buy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy));
    if (message_arena != submessage_arena) {
      coin_to_buy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_buy, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_buy_ = coin_to_buy;
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellCoinData.coin_to_buy)
}

// string minimum_value_to_buy = 4 [json_name = "minimumValueToBuy"];
inline void SellCoinData::clear_minimum_value_to_buy() {
  minimum_value_to_buy_.ClearToEmpty();
}
inline const std::string& SellCoinData::minimum_value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellCoinData.minimum_value_to_buy)
  return _internal_minimum_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellCoinData::set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellCoinData.minimum_value_to_buy)
}
inline std::string* SellCoinData::mutable_minimum_value_to_buy() {
  std::string* _s = _internal_mutable_minimum_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellCoinData.minimum_value_to_buy)
  return _s;
}
inline const std::string& SellCoinData::_internal_minimum_value_to_buy() const {
  return minimum_value_to_buy_.Get();
}
inline void SellCoinData::_internal_set_minimum_value_to_buy(const std::string& value) {
  
  minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellCoinData::_internal_mutable_minimum_value_to_buy() {
  
  return minimum_value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellCoinData::release_minimum_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellCoinData.minimum_value_to_buy)
  return minimum_value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellCoinData::set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy) {
  if (minimum_value_to_buy != nullptr) {
    
  } else {
    
  }
  minimum_value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellCoinData.minimum_value_to_buy)
}

// -------------------------------------------------------------------

// SellAllCoinData

// .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
inline bool SellAllCoinData::_internal_has_coin_to_sell() const {
  return this != internal_default_instance() && coin_to_sell_ != nullptr;
}
inline bool SellAllCoinData::has_coin_to_sell() const {
  return _internal_has_coin_to_sell();
}
inline const ::api_pb::Coin& SellAllCoinData::_internal_coin_to_sell() const {
  const ::api_pb::Coin* p = coin_to_sell_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& SellAllCoinData::coin_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.SellAllCoinData.coin_to_sell)
  return _internal_coin_to_sell();
}
inline void SellAllCoinData::unsafe_arena_set_allocated_coin_to_sell(
    ::api_pb::Coin* coin_to_sell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  coin_to_sell_ = coin_to_sell;
  if (coin_to_sell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.SellAllCoinData.coin_to_sell)
}
inline ::api_pb::Coin* SellAllCoinData::release_coin_to_sell() {
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* SellAllCoinData::unsafe_arena_release_coin_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.SellAllCoinData.coin_to_sell)
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* SellAllCoinData::_internal_mutable_coin_to_sell() {
  
  if (coin_to_sell_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_sell_ = p;
  }
  return coin_to_sell_;
}
inline ::api_pb::Coin* SellAllCoinData::mutable_coin_to_sell() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.SellAllCoinData.coin_to_sell)
  return _msg;
}
inline void SellAllCoinData::set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  if (coin_to_sell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell));
    if (message_arena != submessage_arena) {
      coin_to_sell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_sell, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_sell_ = coin_to_sell;
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellAllCoinData.coin_to_sell)
}

// .api_pb.Coin coin_to_buy = 2 [json_name = "coinToBuy"];
inline bool SellAllCoinData::_internal_has_coin_to_buy() const {
  return this != internal_default_instance() && coin_to_buy_ != nullptr;
}
inline bool SellAllCoinData::has_coin_to_buy() const {
  return _internal_has_coin_to_buy();
}
inline const ::api_pb::Coin& SellAllCoinData::_internal_coin_to_buy() const {
  const ::api_pb::Coin* p = coin_to_buy_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& SellAllCoinData::coin_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellAllCoinData.coin_to_buy)
  return _internal_coin_to_buy();
}
inline void SellAllCoinData::unsafe_arena_set_allocated_coin_to_buy(
    ::api_pb::Coin* coin_to_buy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  coin_to_buy_ = coin_to_buy;
  if (coin_to_buy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.SellAllCoinData.coin_to_buy)
}
inline ::api_pb::Coin* SellAllCoinData::release_coin_to_buy() {
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* SellAllCoinData::unsafe_arena_release_coin_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellAllCoinData.coin_to_buy)
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* SellAllCoinData::_internal_mutable_coin_to_buy() {
  
  if (coin_to_buy_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_buy_ = p;
  }
  return coin_to_buy_;
}
inline ::api_pb::Coin* SellAllCoinData::mutable_coin_to_buy() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellAllCoinData.coin_to_buy)
  return _msg;
}
inline void SellAllCoinData::set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  if (coin_to_buy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy));
    if (message_arena != submessage_arena) {
      coin_to_buy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_buy, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_buy_ = coin_to_buy;
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellAllCoinData.coin_to_buy)
}

// string minimum_value_to_buy = 3 [json_name = "minimumValueToBuy"];
inline void SellAllCoinData::clear_minimum_value_to_buy() {
  minimum_value_to_buy_.ClearToEmpty();
}
inline const std::string& SellAllCoinData::minimum_value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellAllCoinData.minimum_value_to_buy)
  return _internal_minimum_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellAllCoinData::set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellAllCoinData.minimum_value_to_buy)
}
inline std::string* SellAllCoinData::mutable_minimum_value_to_buy() {
  std::string* _s = _internal_mutable_minimum_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellAllCoinData.minimum_value_to_buy)
  return _s;
}
inline const std::string& SellAllCoinData::_internal_minimum_value_to_buy() const {
  return minimum_value_to_buy_.Get();
}
inline void SellAllCoinData::_internal_set_minimum_value_to_buy(const std::string& value) {
  
  minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellAllCoinData::_internal_mutable_minimum_value_to_buy() {
  
  return minimum_value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellAllCoinData::release_minimum_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellAllCoinData.minimum_value_to_buy)
  return minimum_value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellAllCoinData::set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy) {
  if (minimum_value_to_buy != nullptr) {
    
  } else {
    
  }
  minimum_value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellAllCoinData.minimum_value_to_buy)
}

// -------------------------------------------------------------------

// BuyCoinData

// .api_pb.Coin coin_to_buy = 1 [json_name = "coinToBuy"];
inline bool BuyCoinData::_internal_has_coin_to_buy() const {
  return this != internal_default_instance() && coin_to_buy_ != nullptr;
}
inline bool BuyCoinData::has_coin_to_buy() const {
  return _internal_has_coin_to_buy();
}
inline const ::api_pb::Coin& BuyCoinData::_internal_coin_to_buy() const {
  const ::api_pb::Coin* p = coin_to_buy_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& BuyCoinData::coin_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.BuyCoinData.coin_to_buy)
  return _internal_coin_to_buy();
}
inline void BuyCoinData::unsafe_arena_set_allocated_coin_to_buy(
    ::api_pb::Coin* coin_to_buy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  coin_to_buy_ = coin_to_buy;
  if (coin_to_buy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.BuyCoinData.coin_to_buy)
}
inline ::api_pb::Coin* BuyCoinData::release_coin_to_buy() {
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* BuyCoinData::unsafe_arena_release_coin_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.BuyCoinData.coin_to_buy)
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* BuyCoinData::_internal_mutable_coin_to_buy() {
  
  if (coin_to_buy_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_buy_ = p;
  }
  return coin_to_buy_;
}
inline ::api_pb::Coin* BuyCoinData::mutable_coin_to_buy() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.BuyCoinData.coin_to_buy)
  return _msg;
}
inline void BuyCoinData::set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  if (coin_to_buy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy));
    if (message_arena != submessage_arena) {
      coin_to_buy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_buy, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_buy_ = coin_to_buy;
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuyCoinData.coin_to_buy)
}

// string value_to_buy = 2 [json_name = "valueToBuy"];
inline void BuyCoinData::clear_value_to_buy() {
  value_to_buy_.ClearToEmpty();
}
inline const std::string& BuyCoinData::value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.BuyCoinData.value_to_buy)
  return _internal_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyCoinData::set_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.BuyCoinData.value_to_buy)
}
inline std::string* BuyCoinData::mutable_value_to_buy() {
  std::string* _s = _internal_mutable_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.BuyCoinData.value_to_buy)
  return _s;
}
inline const std::string& BuyCoinData::_internal_value_to_buy() const {
  return value_to_buy_.Get();
}
inline void BuyCoinData::_internal_set_value_to_buy(const std::string& value) {
  
  value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BuyCoinData::_internal_mutable_value_to_buy() {
  
  return value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BuyCoinData::release_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.BuyCoinData.value_to_buy)
  return value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BuyCoinData::set_allocated_value_to_buy(std::string* value_to_buy) {
  if (value_to_buy != nullptr) {
    
  } else {
    
  }
  value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuyCoinData.value_to_buy)
}

// .api_pb.Coin coin_to_sell = 3 [json_name = "coinToSell"];
inline bool BuyCoinData::_internal_has_coin_to_sell() const {
  return this != internal_default_instance() && coin_to_sell_ != nullptr;
}
inline bool BuyCoinData::has_coin_to_sell() const {
  return _internal_has_coin_to_sell();
}
inline const ::api_pb::Coin& BuyCoinData::_internal_coin_to_sell() const {
  const ::api_pb::Coin* p = coin_to_sell_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& BuyCoinData::coin_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.BuyCoinData.coin_to_sell)
  return _internal_coin_to_sell();
}
inline void BuyCoinData::unsafe_arena_set_allocated_coin_to_sell(
    ::api_pb::Coin* coin_to_sell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  coin_to_sell_ = coin_to_sell;
  if (coin_to_sell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.BuyCoinData.coin_to_sell)
}
inline ::api_pb::Coin* BuyCoinData::release_coin_to_sell() {
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* BuyCoinData::unsafe_arena_release_coin_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.BuyCoinData.coin_to_sell)
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* BuyCoinData::_internal_mutable_coin_to_sell() {
  
  if (coin_to_sell_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_sell_ = p;
  }
  return coin_to_sell_;
}
inline ::api_pb::Coin* BuyCoinData::mutable_coin_to_sell() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.BuyCoinData.coin_to_sell)
  return _msg;
}
inline void BuyCoinData::set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  if (coin_to_sell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell));
    if (message_arena != submessage_arena) {
      coin_to_sell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_sell, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_sell_ = coin_to_sell;
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuyCoinData.coin_to_sell)
}

// string maximum_value_to_sell = 4 [json_name = "maximumValueToSell"];
inline void BuyCoinData::clear_maximum_value_to_sell() {
  maximum_value_to_sell_.ClearToEmpty();
}
inline const std::string& BuyCoinData::maximum_value_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.BuyCoinData.maximum_value_to_sell)
  return _internal_maximum_value_to_sell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyCoinData::set_maximum_value_to_sell(ArgT0&& arg0, ArgT... args) {
 
 maximum_value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.BuyCoinData.maximum_value_to_sell)
}
inline std::string* BuyCoinData::mutable_maximum_value_to_sell() {
  std::string* _s = _internal_mutable_maximum_value_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.BuyCoinData.maximum_value_to_sell)
  return _s;
}
inline const std::string& BuyCoinData::_internal_maximum_value_to_sell() const {
  return maximum_value_to_sell_.Get();
}
inline void BuyCoinData::_internal_set_maximum_value_to_sell(const std::string& value) {
  
  maximum_value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BuyCoinData::_internal_mutable_maximum_value_to_sell() {
  
  return maximum_value_to_sell_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BuyCoinData::release_maximum_value_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.BuyCoinData.maximum_value_to_sell)
  return maximum_value_to_sell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BuyCoinData::set_allocated_maximum_value_to_sell(std::string* maximum_value_to_sell) {
  if (maximum_value_to_sell != nullptr) {
    
  } else {
    
  }
  maximum_value_to_sell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maximum_value_to_sell,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuyCoinData.maximum_value_to_sell)
}

// -------------------------------------------------------------------

// CreateCoinData

// string name = 1 [json_name = "name"];
inline void CreateCoinData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateCoinData::name() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoinData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.name)
}
inline std::string* CreateCoinData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateCoinData.name)
  return _s;
}
inline const std::string& CreateCoinData::_internal_name() const {
  return name_.Get();
}
inline void CreateCoinData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoinData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoinData::release_name() {
  // @@protoc_insertion_point(field_release:api_pb.CreateCoinData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCoinData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateCoinData.name)
}

// string symbol = 2 [json_name = "symbol"];
inline void CreateCoinData::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& CreateCoinData::symbol() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoinData::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.symbol)
}
inline std::string* CreateCoinData::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateCoinData.symbol)
  return _s;
}
inline const std::string& CreateCoinData::_internal_symbol() const {
  return symbol_.Get();
}
inline void CreateCoinData::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoinData::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoinData::release_symbol() {
  // @@protoc_insertion_point(field_release:api_pb.CreateCoinData.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCoinData::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateCoinData.symbol)
}

// string initial_amount = 3 [json_name = "initialAmount"];
inline void CreateCoinData::clear_initial_amount() {
  initial_amount_.ClearToEmpty();
}
inline const std::string& CreateCoinData::initial_amount() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.initial_amount)
  return _internal_initial_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoinData::set_initial_amount(ArgT0&& arg0, ArgT... args) {
 
 initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.initial_amount)
}
inline std::string* CreateCoinData::mutable_initial_amount() {
  std::string* _s = _internal_mutable_initial_amount();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateCoinData.initial_amount)
  return _s;
}
inline const std::string& CreateCoinData::_internal_initial_amount() const {
  return initial_amount_.Get();
}
inline void CreateCoinData::_internal_set_initial_amount(const std::string& value) {
  
  initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoinData::_internal_mutable_initial_amount() {
  
  return initial_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoinData::release_initial_amount() {
  // @@protoc_insertion_point(field_release:api_pb.CreateCoinData.initial_amount)
  return initial_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCoinData::set_allocated_initial_amount(std::string* initial_amount) {
  if (initial_amount != nullptr) {
    
  } else {
    
  }
  initial_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateCoinData.initial_amount)
}

// string initial_reserve = 4 [json_name = "initialReserve"];
inline void CreateCoinData::clear_initial_reserve() {
  initial_reserve_.ClearToEmpty();
}
inline const std::string& CreateCoinData::initial_reserve() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.initial_reserve)
  return _internal_initial_reserve();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoinData::set_initial_reserve(ArgT0&& arg0, ArgT... args) {
 
 initial_reserve_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.initial_reserve)
}
inline std::string* CreateCoinData::mutable_initial_reserve() {
  std::string* _s = _internal_mutable_initial_reserve();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateCoinData.initial_reserve)
  return _s;
}
inline const std::string& CreateCoinData::_internal_initial_reserve() const {
  return initial_reserve_.Get();
}
inline void CreateCoinData::_internal_set_initial_reserve(const std::string& value) {
  
  initial_reserve_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoinData::_internal_mutable_initial_reserve() {
  
  return initial_reserve_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoinData::release_initial_reserve() {
  // @@protoc_insertion_point(field_release:api_pb.CreateCoinData.initial_reserve)
  return initial_reserve_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCoinData::set_allocated_initial_reserve(std::string* initial_reserve) {
  if (initial_reserve != nullptr) {
    
  } else {
    
  }
  initial_reserve_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_reserve,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateCoinData.initial_reserve)
}

// uint64 constant_reserve_ratio = 5 [json_name = "constantReserveRatio"];
inline void CreateCoinData::clear_constant_reserve_ratio() {
  constant_reserve_ratio_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateCoinData::_internal_constant_reserve_ratio() const {
  return constant_reserve_ratio_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateCoinData::constant_reserve_ratio() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.constant_reserve_ratio)
  return _internal_constant_reserve_ratio();
}
inline void CreateCoinData::_internal_set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  constant_reserve_ratio_ = value;
}
inline void CreateCoinData::set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_constant_reserve_ratio(value);
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.constant_reserve_ratio)
}

// string max_supply = 6 [json_name = "maxSupply"];
inline void CreateCoinData::clear_max_supply() {
  max_supply_.ClearToEmpty();
}
inline const std::string& CreateCoinData::max_supply() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateCoinData.max_supply)
  return _internal_max_supply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoinData::set_max_supply(ArgT0&& arg0, ArgT... args) {
 
 max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateCoinData.max_supply)
}
inline std::string* CreateCoinData::mutable_max_supply() {
  std::string* _s = _internal_mutable_max_supply();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateCoinData.max_supply)
  return _s;
}
inline const std::string& CreateCoinData::_internal_max_supply() const {
  return max_supply_.Get();
}
inline void CreateCoinData::_internal_set_max_supply(const std::string& value) {
  
  max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoinData::_internal_mutable_max_supply() {
  
  return max_supply_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoinData::release_max_supply() {
  // @@protoc_insertion_point(field_release:api_pb.CreateCoinData.max_supply)
  return max_supply_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCoinData::set_allocated_max_supply(std::string* max_supply) {
  if (max_supply != nullptr) {
    
  } else {
    
  }
  max_supply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_supply,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateCoinData.max_supply)
}

// -------------------------------------------------------------------

// DeclareCandidacyData

// string address = 1 [json_name = "address"];
inline void DeclareCandidacyData::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& DeclareCandidacyData::address() const {
  // @@protoc_insertion_point(field_get:api_pb.DeclareCandidacyData.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeclareCandidacyData::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.DeclareCandidacyData.address)
}
inline std::string* DeclareCandidacyData::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:api_pb.DeclareCandidacyData.address)
  return _s;
}
inline const std::string& DeclareCandidacyData::_internal_address() const {
  return address_.Get();
}
inline void DeclareCandidacyData::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::release_address() {
  // @@protoc_insertion_point(field_release:api_pb.DeclareCandidacyData.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeclareCandidacyData::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.DeclareCandidacyData.address)
}

// string pub_key = 2 [json_name = "pubKey"];
inline void DeclareCandidacyData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& DeclareCandidacyData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.DeclareCandidacyData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeclareCandidacyData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.DeclareCandidacyData.pub_key)
}
inline std::string* DeclareCandidacyData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.DeclareCandidacyData.pub_key)
  return _s;
}
inline const std::string& DeclareCandidacyData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void DeclareCandidacyData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.DeclareCandidacyData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeclareCandidacyData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.DeclareCandidacyData.pub_key)
}

// uint64 commission = 3 [json_name = "commission"];
inline void DeclareCandidacyData::clear_commission() {
  commission_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeclareCandidacyData::_internal_commission() const {
  return commission_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeclareCandidacyData::commission() const {
  // @@protoc_insertion_point(field_get:api_pb.DeclareCandidacyData.commission)
  return _internal_commission();
}
inline void DeclareCandidacyData::_internal_set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  commission_ = value;
}
inline void DeclareCandidacyData::set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_commission(value);
  // @@protoc_insertion_point(field_set:api_pb.DeclareCandidacyData.commission)
}

// .api_pb.Coin coin = 4 [json_name = "coin"];
inline bool DeclareCandidacyData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool DeclareCandidacyData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& DeclareCandidacyData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& DeclareCandidacyData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.DeclareCandidacyData.coin)
  return _internal_coin();
}
inline void DeclareCandidacyData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.DeclareCandidacyData.coin)
}
inline ::api_pb::Coin* DeclareCandidacyData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* DeclareCandidacyData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.DeclareCandidacyData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* DeclareCandidacyData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* DeclareCandidacyData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.DeclareCandidacyData.coin)
  return _msg;
}
inline void DeclareCandidacyData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.DeclareCandidacyData.coin)
}

// string stake = 5 [json_name = "stake"];
inline void DeclareCandidacyData::clear_stake() {
  stake_.ClearToEmpty();
}
inline const std::string& DeclareCandidacyData::stake() const {
  // @@protoc_insertion_point(field_get:api_pb.DeclareCandidacyData.stake)
  return _internal_stake();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeclareCandidacyData::set_stake(ArgT0&& arg0, ArgT... args) {
 
 stake_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.DeclareCandidacyData.stake)
}
inline std::string* DeclareCandidacyData::mutable_stake() {
  std::string* _s = _internal_mutable_stake();
  // @@protoc_insertion_point(field_mutable:api_pb.DeclareCandidacyData.stake)
  return _s;
}
inline const std::string& DeclareCandidacyData::_internal_stake() const {
  return stake_.Get();
}
inline void DeclareCandidacyData::_internal_set_stake(const std::string& value) {
  
  stake_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::_internal_mutable_stake() {
  
  return stake_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeclareCandidacyData::release_stake() {
  // @@protoc_insertion_point(field_release:api_pb.DeclareCandidacyData.stake)
  return stake_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeclareCandidacyData::set_allocated_stake(std::string* stake) {
  if (stake != nullptr) {
    
  } else {
    
  }
  stake_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stake,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.DeclareCandidacyData.stake)
}

// -------------------------------------------------------------------

// DelegateData

// string pub_key = 1 [json_name = "pubKey"];
inline void DelegateData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& DelegateData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.DelegateData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.DelegateData.pub_key)
}
inline std::string* DelegateData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.DelegateData.pub_key)
  return _s;
}
inline const std::string& DelegateData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void DelegateData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegateData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegateData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.DelegateData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegateData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.DelegateData.pub_key)
}

// .api_pb.Coin coin = 2 [json_name = "coin"];
inline bool DelegateData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool DelegateData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& DelegateData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& DelegateData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.DelegateData.coin)
  return _internal_coin();
}
inline void DelegateData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.DelegateData.coin)
}
inline ::api_pb::Coin* DelegateData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* DelegateData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.DelegateData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* DelegateData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* DelegateData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.DelegateData.coin)
  return _msg;
}
inline void DelegateData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.DelegateData.coin)
}

// string value = 3 [json_name = "value"];
inline void DelegateData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& DelegateData::value() const {
  // @@protoc_insertion_point(field_get:api_pb.DelegateData.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.DelegateData.value)
}
inline std::string* DelegateData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api_pb.DelegateData.value)
  return _s;
}
inline const std::string& DelegateData::_internal_value() const {
  return value_.Get();
}
inline void DelegateData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegateData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegateData::release_value() {
  // @@protoc_insertion_point(field_release:api_pb.DelegateData.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegateData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.DelegateData.value)
}

// -------------------------------------------------------------------

// UnbondData

// string pub_key = 1 [json_name = "pubKey"];
inline void UnbondData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& UnbondData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.UnbondData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnbondData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.UnbondData.pub_key)
}
inline std::string* UnbondData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.UnbondData.pub_key)
  return _s;
}
inline const std::string& UnbondData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void UnbondData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnbondData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnbondData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.UnbondData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnbondData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.UnbondData.pub_key)
}

// .api_pb.Coin coin = 2 [json_name = "coin"];
inline bool UnbondData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool UnbondData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& UnbondData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& UnbondData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.UnbondData.coin)
  return _internal_coin();
}
inline void UnbondData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.UnbondData.coin)
}
inline ::api_pb::Coin* UnbondData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* UnbondData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.UnbondData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* UnbondData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* UnbondData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.UnbondData.coin)
  return _msg;
}
inline void UnbondData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.UnbondData.coin)
}

// string value = 3 [json_name = "value"];
inline void UnbondData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& UnbondData::value() const {
  // @@protoc_insertion_point(field_get:api_pb.UnbondData.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnbondData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.UnbondData.value)
}
inline std::string* UnbondData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api_pb.UnbondData.value)
  return _s;
}
inline const std::string& UnbondData::_internal_value() const {
  return value_.Get();
}
inline void UnbondData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnbondData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnbondData::release_value() {
  // @@protoc_insertion_point(field_release:api_pb.UnbondData.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnbondData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.UnbondData.value)
}

// -------------------------------------------------------------------

// RedeemCheckData

// string raw_check = 1 [json_name = "rawCheck"];
inline void RedeemCheckData::clear_raw_check() {
  raw_check_.ClearToEmpty();
}
inline const std::string& RedeemCheckData::raw_check() const {
  // @@protoc_insertion_point(field_get:api_pb.RedeemCheckData.raw_check)
  return _internal_raw_check();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedeemCheckData::set_raw_check(ArgT0&& arg0, ArgT... args) {
 
 raw_check_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RedeemCheckData.raw_check)
}
inline std::string* RedeemCheckData::mutable_raw_check() {
  std::string* _s = _internal_mutable_raw_check();
  // @@protoc_insertion_point(field_mutable:api_pb.RedeemCheckData.raw_check)
  return _s;
}
inline const std::string& RedeemCheckData::_internal_raw_check() const {
  return raw_check_.Get();
}
inline void RedeemCheckData::_internal_set_raw_check(const std::string& value) {
  
  raw_check_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RedeemCheckData::_internal_mutable_raw_check() {
  
  return raw_check_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RedeemCheckData::release_raw_check() {
  // @@protoc_insertion_point(field_release:api_pb.RedeemCheckData.raw_check)
  return raw_check_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RedeemCheckData::set_allocated_raw_check(std::string* raw_check) {
  if (raw_check != nullptr) {
    
  } else {
    
  }
  raw_check_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_check,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RedeemCheckData.raw_check)
}

// string proof = 2 [json_name = "proof"];
inline void RedeemCheckData::clear_proof() {
  proof_.ClearToEmpty();
}
inline const std::string& RedeemCheckData::proof() const {
  // @@protoc_insertion_point(field_get:api_pb.RedeemCheckData.proof)
  return _internal_proof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedeemCheckData::set_proof(ArgT0&& arg0, ArgT... args) {
 
 proof_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RedeemCheckData.proof)
}
inline std::string* RedeemCheckData::mutable_proof() {
  std::string* _s = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:api_pb.RedeemCheckData.proof)
  return _s;
}
inline const std::string& RedeemCheckData::_internal_proof() const {
  return proof_.Get();
}
inline void RedeemCheckData::_internal_set_proof(const std::string& value) {
  
  proof_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RedeemCheckData::_internal_mutable_proof() {
  
  return proof_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RedeemCheckData::release_proof() {
  // @@protoc_insertion_point(field_release:api_pb.RedeemCheckData.proof)
  return proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RedeemCheckData::set_allocated_proof(std::string* proof) {
  if (proof != nullptr) {
    
  } else {
    
  }
  proof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proof,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RedeemCheckData.proof)
}

// -------------------------------------------------------------------

// SetCandidateOnData

// string pub_key = 1 [json_name = "pubKey"];
inline void SetCandidateOnData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& SetCandidateOnData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.SetCandidateOnData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetCandidateOnData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SetCandidateOnData.pub_key)
}
inline std::string* SetCandidateOnData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.SetCandidateOnData.pub_key)
  return _s;
}
inline const std::string& SetCandidateOnData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void SetCandidateOnData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetCandidateOnData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetCandidateOnData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.SetCandidateOnData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetCandidateOnData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SetCandidateOnData.pub_key)
}

// -------------------------------------------------------------------

// SetCandidateOffData

// string pub_key = 1 [json_name = "pubKey"];
inline void SetCandidateOffData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& SetCandidateOffData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.SetCandidateOffData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetCandidateOffData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SetCandidateOffData.pub_key)
}
inline std::string* SetCandidateOffData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.SetCandidateOffData.pub_key)
  return _s;
}
inline const std::string& SetCandidateOffData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void SetCandidateOffData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetCandidateOffData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetCandidateOffData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.SetCandidateOffData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetCandidateOffData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SetCandidateOffData.pub_key)
}

// -------------------------------------------------------------------

// CreateMultisigData

// uint64 threshold = 1 [json_name = "threshold"];
inline void CreateMultisigData::clear_threshold() {
  threshold_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateMultisigData::_internal_threshold() const {
  return threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateMultisigData::threshold() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateMultisigData.threshold)
  return _internal_threshold();
}
inline void CreateMultisigData::_internal_set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  threshold_ = value;
}
inline void CreateMultisigData::set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:api_pb.CreateMultisigData.threshold)
}

// repeated uint64 weights = 2 [json_name = "weights"];
inline int CreateMultisigData::_internal_weights_size() const {
  return weights_.size();
}
inline int CreateMultisigData::weights_size() const {
  return _internal_weights_size();
}
inline void CreateMultisigData::clear_weights() {
  weights_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateMultisigData::_internal_weights(int index) const {
  return weights_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateMultisigData::weights(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.CreateMultisigData.weights)
  return _internal_weights(index);
}
inline void CreateMultisigData::set_weights(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:api_pb.CreateMultisigData.weights)
}
inline void CreateMultisigData::_internal_add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  weights_.Add(value);
}
inline void CreateMultisigData::add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_weights(value);
  // @@protoc_insertion_point(field_add:api_pb.CreateMultisigData.weights)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
CreateMultisigData::_internal_weights() const {
  return weights_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
CreateMultisigData::weights() const {
  // @@protoc_insertion_point(field_list:api_pb.CreateMultisigData.weights)
  return _internal_weights();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
CreateMultisigData::_internal_mutable_weights() {
  return &weights_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
CreateMultisigData::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.CreateMultisigData.weights)
  return _internal_mutable_weights();
}

// repeated string addresses = 3 [json_name = "addresses"];
inline int CreateMultisigData::_internal_addresses_size() const {
  return addresses_.size();
}
inline int CreateMultisigData::addresses_size() const {
  return _internal_addresses_size();
}
inline void CreateMultisigData::clear_addresses() {
  addresses_.Clear();
}
inline std::string* CreateMultisigData::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:api_pb.CreateMultisigData.addresses)
  return _s;
}
inline const std::string& CreateMultisigData::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const std::string& CreateMultisigData::addresses(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.CreateMultisigData.addresses)
  return _internal_addresses(index);
}
inline std::string* CreateMultisigData::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.CreateMultisigData.addresses)
  return addresses_.Mutable(index);
}
inline void CreateMultisigData::set_addresses(int index, const std::string& value) {
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::set_addresses(int index, std::string&& value) {
  addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api_pb.CreateMultisigData.addresses)
}
inline std::string* CreateMultisigData::_internal_add_addresses() {
  return addresses_.Add();
}
inline void CreateMultisigData::add_addresses(const std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::add_addresses(std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api_pb.CreateMultisigData.addresses)
}
inline void CreateMultisigData::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api_pb.CreateMultisigData.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateMultisigData::addresses() const {
  // @@protoc_insertion_point(field_list:api_pb.CreateMultisigData.addresses)
  return addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateMultisigData::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.CreateMultisigData.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// MultiSendData

// repeated .api_pb.SendData list = 1 [json_name = "list"];
inline int MultiSendData::_internal_list_size() const {
  return list_.size();
}
inline int MultiSendData::list_size() const {
  return _internal_list_size();
}
inline void MultiSendData::clear_list() {
  list_.Clear();
}
inline ::api_pb::SendData* MultiSendData::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.MultiSendData.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::SendData >*
MultiSendData::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.MultiSendData.list)
  return &list_;
}
inline const ::api_pb::SendData& MultiSendData::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::api_pb::SendData& MultiSendData::list(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.MultiSendData.list)
  return _internal_list(index);
}
inline ::api_pb::SendData* MultiSendData::_internal_add_list() {
  return list_.Add();
}
inline ::api_pb::SendData* MultiSendData::add_list() {
  ::api_pb::SendData* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:api_pb.MultiSendData.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::SendData >&
MultiSendData::list() const {
  // @@protoc_insertion_point(field_list:api_pb.MultiSendData.list)
  return list_;
}

// -------------------------------------------------------------------

// EditCandidateData

// string pub_key = 1 [json_name = "pubKey"];
inline void EditCandidateData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& EditCandidateData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidateData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateData.pub_key)
}
inline std::string* EditCandidateData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidateData.pub_key)
  return _s;
}
inline const std::string& EditCandidateData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void EditCandidateData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidateData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidateData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidateData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidateData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidateData.pub_key)
}

// string reward_address = 3 [json_name = "rewardAddress"];
inline void EditCandidateData::clear_reward_address() {
  reward_address_.ClearToEmpty();
}
inline const std::string& EditCandidateData::reward_address() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateData.reward_address)
  return _internal_reward_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidateData::set_reward_address(ArgT0&& arg0, ArgT... args) {
 
 reward_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateData.reward_address)
}
inline std::string* EditCandidateData::mutable_reward_address() {
  std::string* _s = _internal_mutable_reward_address();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidateData.reward_address)
  return _s;
}
inline const std::string& EditCandidateData::_internal_reward_address() const {
  return reward_address_.Get();
}
inline void EditCandidateData::_internal_set_reward_address(const std::string& value) {
  
  reward_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidateData::_internal_mutable_reward_address() {
  
  return reward_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidateData::release_reward_address() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidateData.reward_address)
  return reward_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidateData::set_allocated_reward_address(std::string* reward_address) {
  if (reward_address != nullptr) {
    
  } else {
    
  }
  reward_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reward_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidateData.reward_address)
}

// string owner_address = 4 [json_name = "ownerAddress"];
inline void EditCandidateData::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& EditCandidateData::owner_address() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateData.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidateData::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateData.owner_address)
}
inline std::string* EditCandidateData::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidateData.owner_address)
  return _s;
}
inline const std::string& EditCandidateData::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void EditCandidateData::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidateData::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidateData::release_owner_address() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidateData.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidateData::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidateData.owner_address)
}

// string control_address = 5 [json_name = "controlAddress"];
inline void EditCandidateData::clear_control_address() {
  control_address_.ClearToEmpty();
}
inline const std::string& EditCandidateData::control_address() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateData.control_address)
  return _internal_control_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidateData::set_control_address(ArgT0&& arg0, ArgT... args) {
 
 control_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateData.control_address)
}
inline std::string* EditCandidateData::mutable_control_address() {
  std::string* _s = _internal_mutable_control_address();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidateData.control_address)
  return _s;
}
inline const std::string& EditCandidateData::_internal_control_address() const {
  return control_address_.Get();
}
inline void EditCandidateData::_internal_set_control_address(const std::string& value) {
  
  control_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidateData::_internal_mutable_control_address() {
  
  return control_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidateData::release_control_address() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidateData.control_address)
  return control_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidateData::set_allocated_control_address(std::string* control_address) {
  if (control_address != nullptr) {
    
  } else {
    
  }
  control_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), control_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidateData.control_address)
}

// -------------------------------------------------------------------

// SetHaltBlockData

// string pub_key = 1 [json_name = "pubKey"];
inline void SetHaltBlockData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& SetHaltBlockData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.SetHaltBlockData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetHaltBlockData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SetHaltBlockData.pub_key)
}
inline std::string* SetHaltBlockData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.SetHaltBlockData.pub_key)
  return _s;
}
inline const std::string& SetHaltBlockData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void SetHaltBlockData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetHaltBlockData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetHaltBlockData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.SetHaltBlockData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetHaltBlockData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SetHaltBlockData.pub_key)
}

// uint64 height = 2 [json_name = "height"];
inline void SetHaltBlockData::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetHaltBlockData::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetHaltBlockData::height() const {
  // @@protoc_insertion_point(field_get:api_pb.SetHaltBlockData.height)
  return _internal_height();
}
inline void SetHaltBlockData::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void SetHaltBlockData::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:api_pb.SetHaltBlockData.height)
}

// -------------------------------------------------------------------

// RecreateCoinData

// string name = 1 [json_name = "name"];
inline void RecreateCoinData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RecreateCoinData::name() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateCoinData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.name)
}
inline std::string* RecreateCoinData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateCoinData.name)
  return _s;
}
inline const std::string& RecreateCoinData::_internal_name() const {
  return name_.Get();
}
inline void RecreateCoinData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::release_name() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateCoinData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateCoinData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateCoinData.name)
}

// string symbol = 2 [json_name = "symbol"];
inline void RecreateCoinData::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& RecreateCoinData::symbol() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateCoinData::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.symbol)
}
inline std::string* RecreateCoinData::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateCoinData.symbol)
  return _s;
}
inline const std::string& RecreateCoinData::_internal_symbol() const {
  return symbol_.Get();
}
inline void RecreateCoinData::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::release_symbol() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateCoinData.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateCoinData::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateCoinData.symbol)
}

// string initial_amount = 3 [json_name = "initialAmount"];
inline void RecreateCoinData::clear_initial_amount() {
  initial_amount_.ClearToEmpty();
}
inline const std::string& RecreateCoinData::initial_amount() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.initial_amount)
  return _internal_initial_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateCoinData::set_initial_amount(ArgT0&& arg0, ArgT... args) {
 
 initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.initial_amount)
}
inline std::string* RecreateCoinData::mutable_initial_amount() {
  std::string* _s = _internal_mutable_initial_amount();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateCoinData.initial_amount)
  return _s;
}
inline const std::string& RecreateCoinData::_internal_initial_amount() const {
  return initial_amount_.Get();
}
inline void RecreateCoinData::_internal_set_initial_amount(const std::string& value) {
  
  initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::_internal_mutable_initial_amount() {
  
  return initial_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::release_initial_amount() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateCoinData.initial_amount)
  return initial_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateCoinData::set_allocated_initial_amount(std::string* initial_amount) {
  if (initial_amount != nullptr) {
    
  } else {
    
  }
  initial_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateCoinData.initial_amount)
}

// string initial_reserve = 4 [json_name = "initialReserve"];
inline void RecreateCoinData::clear_initial_reserve() {
  initial_reserve_.ClearToEmpty();
}
inline const std::string& RecreateCoinData::initial_reserve() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.initial_reserve)
  return _internal_initial_reserve();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateCoinData::set_initial_reserve(ArgT0&& arg0, ArgT... args) {
 
 initial_reserve_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.initial_reserve)
}
inline std::string* RecreateCoinData::mutable_initial_reserve() {
  std::string* _s = _internal_mutable_initial_reserve();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateCoinData.initial_reserve)
  return _s;
}
inline const std::string& RecreateCoinData::_internal_initial_reserve() const {
  return initial_reserve_.Get();
}
inline void RecreateCoinData::_internal_set_initial_reserve(const std::string& value) {
  
  initial_reserve_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::_internal_mutable_initial_reserve() {
  
  return initial_reserve_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::release_initial_reserve() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateCoinData.initial_reserve)
  return initial_reserve_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateCoinData::set_allocated_initial_reserve(std::string* initial_reserve) {
  if (initial_reserve != nullptr) {
    
  } else {
    
  }
  initial_reserve_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_reserve,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateCoinData.initial_reserve)
}

// uint64 constant_reserve_ratio = 5 [json_name = "constantReserveRatio"];
inline void RecreateCoinData::clear_constant_reserve_ratio() {
  constant_reserve_ratio_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecreateCoinData::_internal_constant_reserve_ratio() const {
  return constant_reserve_ratio_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecreateCoinData::constant_reserve_ratio() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.constant_reserve_ratio)
  return _internal_constant_reserve_ratio();
}
inline void RecreateCoinData::_internal_set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  constant_reserve_ratio_ = value;
}
inline void RecreateCoinData::set_constant_reserve_ratio(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_constant_reserve_ratio(value);
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.constant_reserve_ratio)
}

// string max_supply = 6 [json_name = "maxSupply"];
inline void RecreateCoinData::clear_max_supply() {
  max_supply_.ClearToEmpty();
}
inline const std::string& RecreateCoinData::max_supply() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateCoinData.max_supply)
  return _internal_max_supply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateCoinData::set_max_supply(ArgT0&& arg0, ArgT... args) {
 
 max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateCoinData.max_supply)
}
inline std::string* RecreateCoinData::mutable_max_supply() {
  std::string* _s = _internal_mutable_max_supply();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateCoinData.max_supply)
  return _s;
}
inline const std::string& RecreateCoinData::_internal_max_supply() const {
  return max_supply_.Get();
}
inline void RecreateCoinData::_internal_set_max_supply(const std::string& value) {
  
  max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::_internal_mutable_max_supply() {
  
  return max_supply_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateCoinData::release_max_supply() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateCoinData.max_supply)
  return max_supply_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateCoinData::set_allocated_max_supply(std::string* max_supply) {
  if (max_supply != nullptr) {
    
  } else {
    
  }
  max_supply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_supply,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateCoinData.max_supply)
}

// -------------------------------------------------------------------

// EditCoinOwnerData

// string symbol = 1 [json_name = "symbol"];
inline void EditCoinOwnerData::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& EditCoinOwnerData::symbol() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCoinOwnerData.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCoinOwnerData::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCoinOwnerData.symbol)
}
inline std::string* EditCoinOwnerData::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCoinOwnerData.symbol)
  return _s;
}
inline const std::string& EditCoinOwnerData::_internal_symbol() const {
  return symbol_.Get();
}
inline void EditCoinOwnerData::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCoinOwnerData::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCoinOwnerData::release_symbol() {
  // @@protoc_insertion_point(field_release:api_pb.EditCoinOwnerData.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCoinOwnerData::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCoinOwnerData.symbol)
}

// string new_owner = 2 [json_name = "newOwner"];
inline void EditCoinOwnerData::clear_new_owner() {
  new_owner_.ClearToEmpty();
}
inline const std::string& EditCoinOwnerData::new_owner() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCoinOwnerData.new_owner)
  return _internal_new_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCoinOwnerData::set_new_owner(ArgT0&& arg0, ArgT... args) {
 
 new_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCoinOwnerData.new_owner)
}
inline std::string* EditCoinOwnerData::mutable_new_owner() {
  std::string* _s = _internal_mutable_new_owner();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCoinOwnerData.new_owner)
  return _s;
}
inline const std::string& EditCoinOwnerData::_internal_new_owner() const {
  return new_owner_.Get();
}
inline void EditCoinOwnerData::_internal_set_new_owner(const std::string& value) {
  
  new_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCoinOwnerData::_internal_mutable_new_owner() {
  
  return new_owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCoinOwnerData::release_new_owner() {
  // @@protoc_insertion_point(field_release:api_pb.EditCoinOwnerData.new_owner)
  return new_owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCoinOwnerData::set_allocated_new_owner(std::string* new_owner) {
  if (new_owner != nullptr) {
    
  } else {
    
  }
  new_owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_owner,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCoinOwnerData.new_owner)
}

// -------------------------------------------------------------------

// EditMultisigData

// uint64 threshold = 1 [json_name = "threshold"];
inline void EditMultisigData::clear_threshold() {
  threshold_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditMultisigData::_internal_threshold() const {
  return threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditMultisigData::threshold() const {
  // @@protoc_insertion_point(field_get:api_pb.EditMultisigData.threshold)
  return _internal_threshold();
}
inline void EditMultisigData::_internal_set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  threshold_ = value;
}
inline void EditMultisigData::set_threshold(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:api_pb.EditMultisigData.threshold)
}

// repeated uint64 weights = 2 [json_name = "weights"];
inline int EditMultisigData::_internal_weights_size() const {
  return weights_.size();
}
inline int EditMultisigData::weights_size() const {
  return _internal_weights_size();
}
inline void EditMultisigData::clear_weights() {
  weights_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditMultisigData::_internal_weights(int index) const {
  return weights_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditMultisigData::weights(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.EditMultisigData.weights)
  return _internal_weights(index);
}
inline void EditMultisigData::set_weights(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:api_pb.EditMultisigData.weights)
}
inline void EditMultisigData::_internal_add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  weights_.Add(value);
}
inline void EditMultisigData::add_weights(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_weights(value);
  // @@protoc_insertion_point(field_add:api_pb.EditMultisigData.weights)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
EditMultisigData::_internal_weights() const {
  return weights_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
EditMultisigData::weights() const {
  // @@protoc_insertion_point(field_list:api_pb.EditMultisigData.weights)
  return _internal_weights();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
EditMultisigData::_internal_mutable_weights() {
  return &weights_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
EditMultisigData::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.EditMultisigData.weights)
  return _internal_mutable_weights();
}

// repeated string addresses = 3 [json_name = "addresses"];
inline int EditMultisigData::_internal_addresses_size() const {
  return addresses_.size();
}
inline int EditMultisigData::addresses_size() const {
  return _internal_addresses_size();
}
inline void EditMultisigData::clear_addresses() {
  addresses_.Clear();
}
inline std::string* EditMultisigData::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:api_pb.EditMultisigData.addresses)
  return _s;
}
inline const std::string& EditMultisigData::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const std::string& EditMultisigData::addresses(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.EditMultisigData.addresses)
  return _internal_addresses(index);
}
inline std::string* EditMultisigData::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.EditMultisigData.addresses)
  return addresses_.Mutable(index);
}
inline void EditMultisigData::set_addresses(int index, const std::string& value) {
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::set_addresses(int index, std::string&& value) {
  addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api_pb.EditMultisigData.addresses)
}
inline std::string* EditMultisigData::_internal_add_addresses() {
  return addresses_.Add();
}
inline void EditMultisigData::add_addresses(const std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::add_addresses(std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api_pb.EditMultisigData.addresses)
}
inline void EditMultisigData::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api_pb.EditMultisigData.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EditMultisigData::addresses() const {
  // @@protoc_insertion_point(field_list:api_pb.EditMultisigData.addresses)
  return addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EditMultisigData::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.EditMultisigData.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// EditCandidatePublicKeyData

// string pub_key = 1 [json_name = "pubKey"];
inline void EditCandidatePublicKeyData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& EditCandidatePublicKeyData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidatePublicKeyData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidatePublicKeyData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidatePublicKeyData.pub_key)
}
inline std::string* EditCandidatePublicKeyData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidatePublicKeyData.pub_key)
  return _s;
}
inline const std::string& EditCandidatePublicKeyData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void EditCandidatePublicKeyData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidatePublicKeyData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidatePublicKeyData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidatePublicKeyData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidatePublicKeyData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidatePublicKeyData.pub_key)
}

// string new_pub_key = 2 [json_name = "newPubKey"];
inline void EditCandidatePublicKeyData::clear_new_pub_key() {
  new_pub_key_.ClearToEmpty();
}
inline const std::string& EditCandidatePublicKeyData::new_pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidatePublicKeyData.new_pub_key)
  return _internal_new_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidatePublicKeyData::set_new_pub_key(ArgT0&& arg0, ArgT... args) {
 
 new_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidatePublicKeyData.new_pub_key)
}
inline std::string* EditCandidatePublicKeyData::mutable_new_pub_key() {
  std::string* _s = _internal_mutable_new_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidatePublicKeyData.new_pub_key)
  return _s;
}
inline const std::string& EditCandidatePublicKeyData::_internal_new_pub_key() const {
  return new_pub_key_.Get();
}
inline void EditCandidatePublicKeyData::_internal_set_new_pub_key(const std::string& value) {
  
  new_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidatePublicKeyData::_internal_mutable_new_pub_key() {
  
  return new_pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidatePublicKeyData::release_new_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidatePublicKeyData.new_pub_key)
  return new_pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidatePublicKeyData::set_allocated_new_pub_key(std::string* new_pub_key) {
  if (new_pub_key != nullptr) {
    
  } else {
    
  }
  new_pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidatePublicKeyData.new_pub_key)
}

// -------------------------------------------------------------------

// CreateSwapPoolData

// .api_pb.Coin coin0 = 1 [json_name = "coin0"];
inline bool CreateSwapPoolData::_internal_has_coin0() const {
  return this != internal_default_instance() && coin0_ != nullptr;
}
inline bool CreateSwapPoolData::has_coin0() const {
  return _internal_has_coin0();
}
inline const ::api_pb::Coin& CreateSwapPoolData::_internal_coin0() const {
  const ::api_pb::Coin* p = coin0_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& CreateSwapPoolData::coin0() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateSwapPoolData.coin0)
  return _internal_coin0();
}
inline void CreateSwapPoolData::unsafe_arena_set_allocated_coin0(
    ::api_pb::Coin* coin0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  coin0_ = coin0;
  if (coin0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.CreateSwapPoolData.coin0)
}
inline ::api_pb::Coin* CreateSwapPoolData::release_coin0() {
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* CreateSwapPoolData::unsafe_arena_release_coin0() {
  // @@protoc_insertion_point(field_release:api_pb.CreateSwapPoolData.coin0)
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* CreateSwapPoolData::_internal_mutable_coin0() {
  
  if (coin0_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin0_ = p;
  }
  return coin0_;
}
inline ::api_pb::Coin* CreateSwapPoolData::mutable_coin0() {
  ::api_pb::Coin* _msg = _internal_mutable_coin0();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateSwapPoolData.coin0)
  return _msg;
}
inline void CreateSwapPoolData::set_allocated_coin0(::api_pb::Coin* coin0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  if (coin0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0));
    if (message_arena != submessage_arena) {
      coin0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin0, submessage_arena);
    }
    
  } else {
    
  }
  coin0_ = coin0;
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateSwapPoolData.coin0)
}

// .api_pb.Coin coin1 = 2 [json_name = "coin1"];
inline bool CreateSwapPoolData::_internal_has_coin1() const {
  return this != internal_default_instance() && coin1_ != nullptr;
}
inline bool CreateSwapPoolData::has_coin1() const {
  return _internal_has_coin1();
}
inline const ::api_pb::Coin& CreateSwapPoolData::_internal_coin1() const {
  const ::api_pb::Coin* p = coin1_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& CreateSwapPoolData::coin1() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateSwapPoolData.coin1)
  return _internal_coin1();
}
inline void CreateSwapPoolData::unsafe_arena_set_allocated_coin1(
    ::api_pb::Coin* coin1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  coin1_ = coin1;
  if (coin1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.CreateSwapPoolData.coin1)
}
inline ::api_pb::Coin* CreateSwapPoolData::release_coin1() {
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* CreateSwapPoolData::unsafe_arena_release_coin1() {
  // @@protoc_insertion_point(field_release:api_pb.CreateSwapPoolData.coin1)
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* CreateSwapPoolData::_internal_mutable_coin1() {
  
  if (coin1_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin1_ = p;
  }
  return coin1_;
}
inline ::api_pb::Coin* CreateSwapPoolData::mutable_coin1() {
  ::api_pb::Coin* _msg = _internal_mutable_coin1();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateSwapPoolData.coin1)
  return _msg;
}
inline void CreateSwapPoolData::set_allocated_coin1(::api_pb::Coin* coin1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  if (coin1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1));
    if (message_arena != submessage_arena) {
      coin1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin1, submessage_arena);
    }
    
  } else {
    
  }
  coin1_ = coin1;
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateSwapPoolData.coin1)
}

// string volume0 = 3 [json_name = "volume0"];
inline void CreateSwapPoolData::clear_volume0() {
  volume0_.ClearToEmpty();
}
inline const std::string& CreateSwapPoolData::volume0() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateSwapPoolData.volume0)
  return _internal_volume0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSwapPoolData::set_volume0(ArgT0&& arg0, ArgT... args) {
 
 volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateSwapPoolData.volume0)
}
inline std::string* CreateSwapPoolData::mutable_volume0() {
  std::string* _s = _internal_mutable_volume0();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateSwapPoolData.volume0)
  return _s;
}
inline const std::string& CreateSwapPoolData::_internal_volume0() const {
  return volume0_.Get();
}
inline void CreateSwapPoolData::_internal_set_volume0(const std::string& value) {
  
  volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSwapPoolData::_internal_mutable_volume0() {
  
  return volume0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSwapPoolData::release_volume0() {
  // @@protoc_insertion_point(field_release:api_pb.CreateSwapPoolData.volume0)
  return volume0_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSwapPoolData::set_allocated_volume0(std::string* volume0) {
  if (volume0 != nullptr) {
    
  } else {
    
  }
  volume0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume0,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateSwapPoolData.volume0)
}

// string volume1 = 4 [json_name = "volume1"];
inline void CreateSwapPoolData::clear_volume1() {
  volume1_.ClearToEmpty();
}
inline const std::string& CreateSwapPoolData::volume1() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateSwapPoolData.volume1)
  return _internal_volume1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSwapPoolData::set_volume1(ArgT0&& arg0, ArgT... args) {
 
 volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateSwapPoolData.volume1)
}
inline std::string* CreateSwapPoolData::mutable_volume1() {
  std::string* _s = _internal_mutable_volume1();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateSwapPoolData.volume1)
  return _s;
}
inline const std::string& CreateSwapPoolData::_internal_volume1() const {
  return volume1_.Get();
}
inline void CreateSwapPoolData::_internal_set_volume1(const std::string& value) {
  
  volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSwapPoolData::_internal_mutable_volume1() {
  
  return volume1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSwapPoolData::release_volume1() {
  // @@protoc_insertion_point(field_release:api_pb.CreateSwapPoolData.volume1)
  return volume1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSwapPoolData::set_allocated_volume1(std::string* volume1) {
  if (volume1 != nullptr) {
    
  } else {
    
  }
  volume1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume1,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateSwapPoolData.volume1)
}

// -------------------------------------------------------------------

// AddLiquidityData

// .api_pb.Coin coin0 = 1 [json_name = "coin0"];
inline bool AddLiquidityData::_internal_has_coin0() const {
  return this != internal_default_instance() && coin0_ != nullptr;
}
inline bool AddLiquidityData::has_coin0() const {
  return _internal_has_coin0();
}
inline const ::api_pb::Coin& AddLiquidityData::_internal_coin0() const {
  const ::api_pb::Coin* p = coin0_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& AddLiquidityData::coin0() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLiquidityData.coin0)
  return _internal_coin0();
}
inline void AddLiquidityData::unsafe_arena_set_allocated_coin0(
    ::api_pb::Coin* coin0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  coin0_ = coin0;
  if (coin0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.AddLiquidityData.coin0)
}
inline ::api_pb::Coin* AddLiquidityData::release_coin0() {
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* AddLiquidityData::unsafe_arena_release_coin0() {
  // @@protoc_insertion_point(field_release:api_pb.AddLiquidityData.coin0)
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* AddLiquidityData::_internal_mutable_coin0() {
  
  if (coin0_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin0_ = p;
  }
  return coin0_;
}
inline ::api_pb::Coin* AddLiquidityData::mutable_coin0() {
  ::api_pb::Coin* _msg = _internal_mutable_coin0();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLiquidityData.coin0)
  return _msg;
}
inline void AddLiquidityData::set_allocated_coin0(::api_pb::Coin* coin0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  if (coin0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0));
    if (message_arena != submessage_arena) {
      coin0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin0, submessage_arena);
    }
    
  } else {
    
  }
  coin0_ = coin0;
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLiquidityData.coin0)
}

// .api_pb.Coin coin1 = 2 [json_name = "coin1"];
inline bool AddLiquidityData::_internal_has_coin1() const {
  return this != internal_default_instance() && coin1_ != nullptr;
}
inline bool AddLiquidityData::has_coin1() const {
  return _internal_has_coin1();
}
inline const ::api_pb::Coin& AddLiquidityData::_internal_coin1() const {
  const ::api_pb::Coin* p = coin1_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& AddLiquidityData::coin1() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLiquidityData.coin1)
  return _internal_coin1();
}
inline void AddLiquidityData::unsafe_arena_set_allocated_coin1(
    ::api_pb::Coin* coin1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  coin1_ = coin1;
  if (coin1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.AddLiquidityData.coin1)
}
inline ::api_pb::Coin* AddLiquidityData::release_coin1() {
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* AddLiquidityData::unsafe_arena_release_coin1() {
  // @@protoc_insertion_point(field_release:api_pb.AddLiquidityData.coin1)
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* AddLiquidityData::_internal_mutable_coin1() {
  
  if (coin1_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin1_ = p;
  }
  return coin1_;
}
inline ::api_pb::Coin* AddLiquidityData::mutable_coin1() {
  ::api_pb::Coin* _msg = _internal_mutable_coin1();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLiquidityData.coin1)
  return _msg;
}
inline void AddLiquidityData::set_allocated_coin1(::api_pb::Coin* coin1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  if (coin1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1));
    if (message_arena != submessage_arena) {
      coin1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin1, submessage_arena);
    }
    
  } else {
    
  }
  coin1_ = coin1;
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLiquidityData.coin1)
}

// string volume0 = 3 [json_name = "volume0"];
inline void AddLiquidityData::clear_volume0() {
  volume0_.ClearToEmpty();
}
inline const std::string& AddLiquidityData::volume0() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLiquidityData.volume0)
  return _internal_volume0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLiquidityData::set_volume0(ArgT0&& arg0, ArgT... args) {
 
 volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.AddLiquidityData.volume0)
}
inline std::string* AddLiquidityData::mutable_volume0() {
  std::string* _s = _internal_mutable_volume0();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLiquidityData.volume0)
  return _s;
}
inline const std::string& AddLiquidityData::_internal_volume0() const {
  return volume0_.Get();
}
inline void AddLiquidityData::_internal_set_volume0(const std::string& value) {
  
  volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddLiquidityData::_internal_mutable_volume0() {
  
  return volume0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddLiquidityData::release_volume0() {
  // @@protoc_insertion_point(field_release:api_pb.AddLiquidityData.volume0)
  return volume0_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddLiquidityData::set_allocated_volume0(std::string* volume0) {
  if (volume0 != nullptr) {
    
  } else {
    
  }
  volume0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume0,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLiquidityData.volume0)
}

// string maximum_volume1 = 4 [json_name = "maximumVolume1"];
inline void AddLiquidityData::clear_maximum_volume1() {
  maximum_volume1_.ClearToEmpty();
}
inline const std::string& AddLiquidityData::maximum_volume1() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLiquidityData.maximum_volume1)
  return _internal_maximum_volume1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLiquidityData::set_maximum_volume1(ArgT0&& arg0, ArgT... args) {
 
 maximum_volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.AddLiquidityData.maximum_volume1)
}
inline std::string* AddLiquidityData::mutable_maximum_volume1() {
  std::string* _s = _internal_mutable_maximum_volume1();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLiquidityData.maximum_volume1)
  return _s;
}
inline const std::string& AddLiquidityData::_internal_maximum_volume1() const {
  return maximum_volume1_.Get();
}
inline void AddLiquidityData::_internal_set_maximum_volume1(const std::string& value) {
  
  maximum_volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddLiquidityData::_internal_mutable_maximum_volume1() {
  
  return maximum_volume1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddLiquidityData::release_maximum_volume1() {
  // @@protoc_insertion_point(field_release:api_pb.AddLiquidityData.maximum_volume1)
  return maximum_volume1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddLiquidityData::set_allocated_maximum_volume1(std::string* maximum_volume1) {
  if (maximum_volume1 != nullptr) {
    
  } else {
    
  }
  maximum_volume1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maximum_volume1,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLiquidityData.maximum_volume1)
}

// -------------------------------------------------------------------

// RemoveLiquidityData

// .api_pb.Coin coin0 = 1 [json_name = "coin0"];
inline bool RemoveLiquidityData::_internal_has_coin0() const {
  return this != internal_default_instance() && coin0_ != nullptr;
}
inline bool RemoveLiquidityData::has_coin0() const {
  return _internal_has_coin0();
}
inline const ::api_pb::Coin& RemoveLiquidityData::_internal_coin0() const {
  const ::api_pb::Coin* p = coin0_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& RemoveLiquidityData::coin0() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLiquidityData.coin0)
  return _internal_coin0();
}
inline void RemoveLiquidityData::unsafe_arena_set_allocated_coin0(
    ::api_pb::Coin* coin0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  coin0_ = coin0;
  if (coin0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.RemoveLiquidityData.coin0)
}
inline ::api_pb::Coin* RemoveLiquidityData::release_coin0() {
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* RemoveLiquidityData::unsafe_arena_release_coin0() {
  // @@protoc_insertion_point(field_release:api_pb.RemoveLiquidityData.coin0)
  
  ::api_pb::Coin* temp = coin0_;
  coin0_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* RemoveLiquidityData::_internal_mutable_coin0() {
  
  if (coin0_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin0_ = p;
  }
  return coin0_;
}
inline ::api_pb::Coin* RemoveLiquidityData::mutable_coin0() {
  ::api_pb::Coin* _msg = _internal_mutable_coin0();
  // @@protoc_insertion_point(field_mutable:api_pb.RemoveLiquidityData.coin0)
  return _msg;
}
inline void RemoveLiquidityData::set_allocated_coin0(::api_pb::Coin* coin0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0_);
  }
  if (coin0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin0));
    if (message_arena != submessage_arena) {
      coin0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin0, submessage_arena);
    }
    
  } else {
    
  }
  coin0_ = coin0;
  // @@protoc_insertion_point(field_set_allocated:api_pb.RemoveLiquidityData.coin0)
}

// .api_pb.Coin coin1 = 2 [json_name = "coin1"];
inline bool RemoveLiquidityData::_internal_has_coin1() const {
  return this != internal_default_instance() && coin1_ != nullptr;
}
inline bool RemoveLiquidityData::has_coin1() const {
  return _internal_has_coin1();
}
inline const ::api_pb::Coin& RemoveLiquidityData::_internal_coin1() const {
  const ::api_pb::Coin* p = coin1_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& RemoveLiquidityData::coin1() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLiquidityData.coin1)
  return _internal_coin1();
}
inline void RemoveLiquidityData::unsafe_arena_set_allocated_coin1(
    ::api_pb::Coin* coin1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  coin1_ = coin1;
  if (coin1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.RemoveLiquidityData.coin1)
}
inline ::api_pb::Coin* RemoveLiquidityData::release_coin1() {
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* RemoveLiquidityData::unsafe_arena_release_coin1() {
  // @@protoc_insertion_point(field_release:api_pb.RemoveLiquidityData.coin1)
  
  ::api_pb::Coin* temp = coin1_;
  coin1_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* RemoveLiquidityData::_internal_mutable_coin1() {
  
  if (coin1_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin1_ = p;
  }
  return coin1_;
}
inline ::api_pb::Coin* RemoveLiquidityData::mutable_coin1() {
  ::api_pb::Coin* _msg = _internal_mutable_coin1();
  // @@protoc_insertion_point(field_mutable:api_pb.RemoveLiquidityData.coin1)
  return _msg;
}
inline void RemoveLiquidityData::set_allocated_coin1(::api_pb::Coin* coin1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1_);
  }
  if (coin1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin1));
    if (message_arena != submessage_arena) {
      coin1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin1, submessage_arena);
    }
    
  } else {
    
  }
  coin1_ = coin1;
  // @@protoc_insertion_point(field_set_allocated:api_pb.RemoveLiquidityData.coin1)
}

// string liquidity = 3 [json_name = "liquidity"];
inline void RemoveLiquidityData::clear_liquidity() {
  liquidity_.ClearToEmpty();
}
inline const std::string& RemoveLiquidityData::liquidity() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLiquidityData.liquidity)
  return _internal_liquidity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveLiquidityData::set_liquidity(ArgT0&& arg0, ArgT... args) {
 
 liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RemoveLiquidityData.liquidity)
}
inline std::string* RemoveLiquidityData::mutable_liquidity() {
  std::string* _s = _internal_mutable_liquidity();
  // @@protoc_insertion_point(field_mutable:api_pb.RemoveLiquidityData.liquidity)
  return _s;
}
inline const std::string& RemoveLiquidityData::_internal_liquidity() const {
  return liquidity_.Get();
}
inline void RemoveLiquidityData::_internal_set_liquidity(const std::string& value) {
  
  liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::_internal_mutable_liquidity() {
  
  return liquidity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::release_liquidity() {
  // @@protoc_insertion_point(field_release:api_pb.RemoveLiquidityData.liquidity)
  return liquidity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveLiquidityData::set_allocated_liquidity(std::string* liquidity) {
  if (liquidity != nullptr) {
    
  } else {
    
  }
  liquidity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), liquidity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RemoveLiquidityData.liquidity)
}

// string minimum_volume0 = 4 [json_name = "minimumVolume0"];
inline void RemoveLiquidityData::clear_minimum_volume0() {
  minimum_volume0_.ClearToEmpty();
}
inline const std::string& RemoveLiquidityData::minimum_volume0() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLiquidityData.minimum_volume0)
  return _internal_minimum_volume0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveLiquidityData::set_minimum_volume0(ArgT0&& arg0, ArgT... args) {
 
 minimum_volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RemoveLiquidityData.minimum_volume0)
}
inline std::string* RemoveLiquidityData::mutable_minimum_volume0() {
  std::string* _s = _internal_mutable_minimum_volume0();
  // @@protoc_insertion_point(field_mutable:api_pb.RemoveLiquidityData.minimum_volume0)
  return _s;
}
inline const std::string& RemoveLiquidityData::_internal_minimum_volume0() const {
  return minimum_volume0_.Get();
}
inline void RemoveLiquidityData::_internal_set_minimum_volume0(const std::string& value) {
  
  minimum_volume0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::_internal_mutable_minimum_volume0() {
  
  return minimum_volume0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::release_minimum_volume0() {
  // @@protoc_insertion_point(field_release:api_pb.RemoveLiquidityData.minimum_volume0)
  return minimum_volume0_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveLiquidityData::set_allocated_minimum_volume0(std::string* minimum_volume0) {
  if (minimum_volume0 != nullptr) {
    
  } else {
    
  }
  minimum_volume0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_volume0,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RemoveLiquidityData.minimum_volume0)
}

// string minimum_volume1 = 5 [json_name = "minimumVolume1"];
inline void RemoveLiquidityData::clear_minimum_volume1() {
  minimum_volume1_.ClearToEmpty();
}
inline const std::string& RemoveLiquidityData::minimum_volume1() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLiquidityData.minimum_volume1)
  return _internal_minimum_volume1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveLiquidityData::set_minimum_volume1(ArgT0&& arg0, ArgT... args) {
 
 minimum_volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RemoveLiquidityData.minimum_volume1)
}
inline std::string* RemoveLiquidityData::mutable_minimum_volume1() {
  std::string* _s = _internal_mutable_minimum_volume1();
  // @@protoc_insertion_point(field_mutable:api_pb.RemoveLiquidityData.minimum_volume1)
  return _s;
}
inline const std::string& RemoveLiquidityData::_internal_minimum_volume1() const {
  return minimum_volume1_.Get();
}
inline void RemoveLiquidityData::_internal_set_minimum_volume1(const std::string& value) {
  
  minimum_volume1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::_internal_mutable_minimum_volume1() {
  
  return minimum_volume1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveLiquidityData::release_minimum_volume1() {
  // @@protoc_insertion_point(field_release:api_pb.RemoveLiquidityData.minimum_volume1)
  return minimum_volume1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveLiquidityData::set_allocated_minimum_volume1(std::string* minimum_volume1) {
  if (minimum_volume1 != nullptr) {
    
  } else {
    
  }
  minimum_volume1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_volume1,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RemoveLiquidityData.minimum_volume1)
}

// -------------------------------------------------------------------

// SellSwapPoolData

// repeated .api_pb.Coin coins = 1 [json_name = "coins"];
inline int SellSwapPoolData::_internal_coins_size() const {
  return coins_.size();
}
inline int SellSwapPoolData::coins_size() const {
  return _internal_coins_size();
}
inline ::api_pb::Coin* SellSwapPoolData::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.SellSwapPoolData.coins)
  return coins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
SellSwapPoolData::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.SellSwapPoolData.coins)
  return &coins_;
}
inline const ::api_pb::Coin& SellSwapPoolData::_internal_coins(int index) const {
  return coins_.Get(index);
}
inline const ::api_pb::Coin& SellSwapPoolData::coins(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.SellSwapPoolData.coins)
  return _internal_coins(index);
}
inline ::api_pb::Coin* SellSwapPoolData::_internal_add_coins() {
  return coins_.Add();
}
inline ::api_pb::Coin* SellSwapPoolData::add_coins() {
  ::api_pb::Coin* _add = _internal_add_coins();
  // @@protoc_insertion_point(field_add:api_pb.SellSwapPoolData.coins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
SellSwapPoolData::coins() const {
  // @@protoc_insertion_point(field_list:api_pb.SellSwapPoolData.coins)
  return coins_;
}

// string value_to_sell = 2 [json_name = "valueToSell"];
inline void SellSwapPoolData::clear_value_to_sell() {
  value_to_sell_.ClearToEmpty();
}
inline const std::string& SellSwapPoolData::value_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.SellSwapPoolData.value_to_sell)
  return _internal_value_to_sell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellSwapPoolData::set_value_to_sell(ArgT0&& arg0, ArgT... args) {
 
 value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellSwapPoolData.value_to_sell)
}
inline std::string* SellSwapPoolData::mutable_value_to_sell() {
  std::string* _s = _internal_mutable_value_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.SellSwapPoolData.value_to_sell)
  return _s;
}
inline const std::string& SellSwapPoolData::_internal_value_to_sell() const {
  return value_to_sell_.Get();
}
inline void SellSwapPoolData::_internal_set_value_to_sell(const std::string& value) {
  
  value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellSwapPoolData::_internal_mutable_value_to_sell() {
  
  return value_to_sell_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellSwapPoolData::release_value_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.SellSwapPoolData.value_to_sell)
  return value_to_sell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellSwapPoolData::set_allocated_value_to_sell(std::string* value_to_sell) {
  if (value_to_sell != nullptr) {
    
  } else {
    
  }
  value_to_sell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_sell,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellSwapPoolData.value_to_sell)
}

// string minimum_value_to_buy = 4 [json_name = "minimumValueToBuy"];
inline void SellSwapPoolData::clear_minimum_value_to_buy() {
  minimum_value_to_buy_.ClearToEmpty();
}
inline const std::string& SellSwapPoolData::minimum_value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellSwapPoolData.minimum_value_to_buy)
  return _internal_minimum_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellSwapPoolData::set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellSwapPoolData.minimum_value_to_buy)
}
inline std::string* SellSwapPoolData::mutable_minimum_value_to_buy() {
  std::string* _s = _internal_mutable_minimum_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellSwapPoolData.minimum_value_to_buy)
  return _s;
}
inline const std::string& SellSwapPoolData::_internal_minimum_value_to_buy() const {
  return minimum_value_to_buy_.Get();
}
inline void SellSwapPoolData::_internal_set_minimum_value_to_buy(const std::string& value) {
  
  minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellSwapPoolData::_internal_mutable_minimum_value_to_buy() {
  
  return minimum_value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellSwapPoolData::release_minimum_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellSwapPoolData.minimum_value_to_buy)
  return minimum_value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellSwapPoolData::set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy) {
  if (minimum_value_to_buy != nullptr) {
    
  } else {
    
  }
  minimum_value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellSwapPoolData.minimum_value_to_buy)
}

// -------------------------------------------------------------------

// SellAllSwapPoolData

// repeated .api_pb.Coin coins = 1 [json_name = "coins"];
inline int SellAllSwapPoolData::_internal_coins_size() const {
  return coins_.size();
}
inline int SellAllSwapPoolData::coins_size() const {
  return _internal_coins_size();
}
inline ::api_pb::Coin* SellAllSwapPoolData::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.SellAllSwapPoolData.coins)
  return coins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
SellAllSwapPoolData::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.SellAllSwapPoolData.coins)
  return &coins_;
}
inline const ::api_pb::Coin& SellAllSwapPoolData::_internal_coins(int index) const {
  return coins_.Get(index);
}
inline const ::api_pb::Coin& SellAllSwapPoolData::coins(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.SellAllSwapPoolData.coins)
  return _internal_coins(index);
}
inline ::api_pb::Coin* SellAllSwapPoolData::_internal_add_coins() {
  return coins_.Add();
}
inline ::api_pb::Coin* SellAllSwapPoolData::add_coins() {
  ::api_pb::Coin* _add = _internal_add_coins();
  // @@protoc_insertion_point(field_add:api_pb.SellAllSwapPoolData.coins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
SellAllSwapPoolData::coins() const {
  // @@protoc_insertion_point(field_list:api_pb.SellAllSwapPoolData.coins)
  return coins_;
}

// string minimum_value_to_buy = 3 [json_name = "minimumValueToBuy"];
inline void SellAllSwapPoolData::clear_minimum_value_to_buy() {
  minimum_value_to_buy_.ClearToEmpty();
}
inline const std::string& SellAllSwapPoolData::minimum_value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.SellAllSwapPoolData.minimum_value_to_buy)
  return _internal_minimum_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellAllSwapPoolData::set_minimum_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.SellAllSwapPoolData.minimum_value_to_buy)
}
inline std::string* SellAllSwapPoolData::mutable_minimum_value_to_buy() {
  std::string* _s = _internal_mutable_minimum_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.SellAllSwapPoolData.minimum_value_to_buy)
  return _s;
}
inline const std::string& SellAllSwapPoolData::_internal_minimum_value_to_buy() const {
  return minimum_value_to_buy_.Get();
}
inline void SellAllSwapPoolData::_internal_set_minimum_value_to_buy(const std::string& value) {
  
  minimum_value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SellAllSwapPoolData::_internal_mutable_minimum_value_to_buy() {
  
  return minimum_value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SellAllSwapPoolData::release_minimum_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.SellAllSwapPoolData.minimum_value_to_buy)
  return minimum_value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SellAllSwapPoolData::set_allocated_minimum_value_to_buy(std::string* minimum_value_to_buy) {
  if (minimum_value_to_buy != nullptr) {
    
  } else {
    
  }
  minimum_value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minimum_value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.SellAllSwapPoolData.minimum_value_to_buy)
}

// -------------------------------------------------------------------

// BuySwapPoolData

// repeated .api_pb.Coin coins = 1 [json_name = "coins"];
inline int BuySwapPoolData::_internal_coins_size() const {
  return coins_.size();
}
inline int BuySwapPoolData::coins_size() const {
  return _internal_coins_size();
}
inline ::api_pb::Coin* BuySwapPoolData::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:api_pb.BuySwapPoolData.coins)
  return coins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >*
BuySwapPoolData::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:api_pb.BuySwapPoolData.coins)
  return &coins_;
}
inline const ::api_pb::Coin& BuySwapPoolData::_internal_coins(int index) const {
  return coins_.Get(index);
}
inline const ::api_pb::Coin& BuySwapPoolData::coins(int index) const {
  // @@protoc_insertion_point(field_get:api_pb.BuySwapPoolData.coins)
  return _internal_coins(index);
}
inline ::api_pb::Coin* BuySwapPoolData::_internal_add_coins() {
  return coins_.Add();
}
inline ::api_pb::Coin* BuySwapPoolData::add_coins() {
  ::api_pb::Coin* _add = _internal_add_coins();
  // @@protoc_insertion_point(field_add:api_pb.BuySwapPoolData.coins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api_pb::Coin >&
BuySwapPoolData::coins() const {
  // @@protoc_insertion_point(field_list:api_pb.BuySwapPoolData.coins)
  return coins_;
}

// string value_to_buy = 2 [json_name = "valueToBuy"];
inline void BuySwapPoolData::clear_value_to_buy() {
  value_to_buy_.ClearToEmpty();
}
inline const std::string& BuySwapPoolData::value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.BuySwapPoolData.value_to_buy)
  return _internal_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuySwapPoolData::set_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.BuySwapPoolData.value_to_buy)
}
inline std::string* BuySwapPoolData::mutable_value_to_buy() {
  std::string* _s = _internal_mutable_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.BuySwapPoolData.value_to_buy)
  return _s;
}
inline const std::string& BuySwapPoolData::_internal_value_to_buy() const {
  return value_to_buy_.Get();
}
inline void BuySwapPoolData::_internal_set_value_to_buy(const std::string& value) {
  
  value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BuySwapPoolData::_internal_mutable_value_to_buy() {
  
  return value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BuySwapPoolData::release_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.BuySwapPoolData.value_to_buy)
  return value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BuySwapPoolData::set_allocated_value_to_buy(std::string* value_to_buy) {
  if (value_to_buy != nullptr) {
    
  } else {
    
  }
  value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuySwapPoolData.value_to_buy)
}

// string maximum_value_to_sell = 4 [json_name = "maximumValueToSell"];
inline void BuySwapPoolData::clear_maximum_value_to_sell() {
  maximum_value_to_sell_.ClearToEmpty();
}
inline const std::string& BuySwapPoolData::maximum_value_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.BuySwapPoolData.maximum_value_to_sell)
  return _internal_maximum_value_to_sell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuySwapPoolData::set_maximum_value_to_sell(ArgT0&& arg0, ArgT... args) {
 
 maximum_value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.BuySwapPoolData.maximum_value_to_sell)
}
inline std::string* BuySwapPoolData::mutable_maximum_value_to_sell() {
  std::string* _s = _internal_mutable_maximum_value_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.BuySwapPoolData.maximum_value_to_sell)
  return _s;
}
inline const std::string& BuySwapPoolData::_internal_maximum_value_to_sell() const {
  return maximum_value_to_sell_.Get();
}
inline void BuySwapPoolData::_internal_set_maximum_value_to_sell(const std::string& value) {
  
  maximum_value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BuySwapPoolData::_internal_mutable_maximum_value_to_sell() {
  
  return maximum_value_to_sell_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BuySwapPoolData::release_maximum_value_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.BuySwapPoolData.maximum_value_to_sell)
  return maximum_value_to_sell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BuySwapPoolData::set_allocated_maximum_value_to_sell(std::string* maximum_value_to_sell) {
  if (maximum_value_to_sell != nullptr) {
    
  } else {
    
  }
  maximum_value_to_sell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maximum_value_to_sell,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.BuySwapPoolData.maximum_value_to_sell)
}

// -------------------------------------------------------------------

// EditCandidateCommission

// string pub_key = 1 [json_name = "pubKey"];
inline void EditCandidateCommission::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& EditCandidateCommission::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateCommission.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCandidateCommission::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateCommission.pub_key)
}
inline std::string* EditCandidateCommission::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.EditCandidateCommission.pub_key)
  return _s;
}
inline const std::string& EditCandidateCommission::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void EditCandidateCommission::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCandidateCommission::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCandidateCommission::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.EditCandidateCommission.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCandidateCommission::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.EditCandidateCommission.pub_key)
}

// uint64 commission = 2 [json_name = "commission"];
inline void EditCandidateCommission::clear_commission() {
  commission_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditCandidateCommission::_internal_commission() const {
  return commission_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EditCandidateCommission::commission() const {
  // @@protoc_insertion_point(field_get:api_pb.EditCandidateCommission.commission)
  return _internal_commission();
}
inline void EditCandidateCommission::_internal_set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  commission_ = value;
}
inline void EditCandidateCommission::set_commission(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_commission(value);
  // @@protoc_insertion_point(field_set:api_pb.EditCandidateCommission.commission)
}

// -------------------------------------------------------------------

// MintTokenData

// .api_pb.Coin coin = 1 [json_name = "coin"];
inline bool MintTokenData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool MintTokenData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& MintTokenData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& MintTokenData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.MintTokenData.coin)
  return _internal_coin();
}
inline void MintTokenData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.MintTokenData.coin)
}
inline ::api_pb::Coin* MintTokenData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* MintTokenData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.MintTokenData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* MintTokenData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* MintTokenData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.MintTokenData.coin)
  return _msg;
}
inline void MintTokenData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.MintTokenData.coin)
}

// string value = 2 [json_name = "value"];
inline void MintTokenData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& MintTokenData::value() const {
  // @@protoc_insertion_point(field_get:api_pb.MintTokenData.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MintTokenData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.MintTokenData.value)
}
inline std::string* MintTokenData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api_pb.MintTokenData.value)
  return _s;
}
inline const std::string& MintTokenData::_internal_value() const {
  return value_.Get();
}
inline void MintTokenData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MintTokenData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MintTokenData::release_value() {
  // @@protoc_insertion_point(field_release:api_pb.MintTokenData.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MintTokenData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.MintTokenData.value)
}

// -------------------------------------------------------------------

// BurnTokenData

// .api_pb.Coin coin = 1 [json_name = "coin"];
inline bool BurnTokenData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool BurnTokenData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& BurnTokenData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& BurnTokenData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.BurnTokenData.coin)
  return _internal_coin();
}
inline void BurnTokenData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.BurnTokenData.coin)
}
inline ::api_pb::Coin* BurnTokenData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* BurnTokenData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.BurnTokenData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* BurnTokenData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* BurnTokenData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.BurnTokenData.coin)
  return _msg;
}
inline void BurnTokenData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.BurnTokenData.coin)
}

// string value = 2 [json_name = "value"];
inline void BurnTokenData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& BurnTokenData::value() const {
  // @@protoc_insertion_point(field_get:api_pb.BurnTokenData.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BurnTokenData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.BurnTokenData.value)
}
inline std::string* BurnTokenData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api_pb.BurnTokenData.value)
  return _s;
}
inline const std::string& BurnTokenData::_internal_value() const {
  return value_.Get();
}
inline void BurnTokenData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BurnTokenData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BurnTokenData::release_value() {
  // @@protoc_insertion_point(field_release:api_pb.BurnTokenData.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BurnTokenData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.BurnTokenData.value)
}

// -------------------------------------------------------------------

// CreateTokenData

// string name = 1 [json_name = "name"];
inline void CreateTokenData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateTokenData::name() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.name)
}
inline std::string* CreateTokenData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateTokenData.name)
  return _s;
}
inline const std::string& CreateTokenData::_internal_name() const {
  return name_.Get();
}
inline void CreateTokenData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenData::release_name() {
  // @@protoc_insertion_point(field_release:api_pb.CreateTokenData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateTokenData.name)
}

// string symbol = 2 [json_name = "symbol"];
inline void CreateTokenData::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& CreateTokenData::symbol() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenData::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.symbol)
}
inline std::string* CreateTokenData::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateTokenData.symbol)
  return _s;
}
inline const std::string& CreateTokenData::_internal_symbol() const {
  return symbol_.Get();
}
inline void CreateTokenData::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenData::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenData::release_symbol() {
  // @@protoc_insertion_point(field_release:api_pb.CreateTokenData.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenData::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateTokenData.symbol)
}

// string initial_amount = 3 [json_name = "initialAmount"];
inline void CreateTokenData::clear_initial_amount() {
  initial_amount_.ClearToEmpty();
}
inline const std::string& CreateTokenData::initial_amount() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.initial_amount)
  return _internal_initial_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenData::set_initial_amount(ArgT0&& arg0, ArgT... args) {
 
 initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.initial_amount)
}
inline std::string* CreateTokenData::mutable_initial_amount() {
  std::string* _s = _internal_mutable_initial_amount();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateTokenData.initial_amount)
  return _s;
}
inline const std::string& CreateTokenData::_internal_initial_amount() const {
  return initial_amount_.Get();
}
inline void CreateTokenData::_internal_set_initial_amount(const std::string& value) {
  
  initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenData::_internal_mutable_initial_amount() {
  
  return initial_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenData::release_initial_amount() {
  // @@protoc_insertion_point(field_release:api_pb.CreateTokenData.initial_amount)
  return initial_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenData::set_allocated_initial_amount(std::string* initial_amount) {
  if (initial_amount != nullptr) {
    
  } else {
    
  }
  initial_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateTokenData.initial_amount)
}

// string max_supply = 4 [json_name = "maxSupply"];
inline void CreateTokenData::clear_max_supply() {
  max_supply_.ClearToEmpty();
}
inline const std::string& CreateTokenData::max_supply() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.max_supply)
  return _internal_max_supply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenData::set_max_supply(ArgT0&& arg0, ArgT... args) {
 
 max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.max_supply)
}
inline std::string* CreateTokenData::mutable_max_supply() {
  std::string* _s = _internal_mutable_max_supply();
  // @@protoc_insertion_point(field_mutable:api_pb.CreateTokenData.max_supply)
  return _s;
}
inline const std::string& CreateTokenData::_internal_max_supply() const {
  return max_supply_.Get();
}
inline void CreateTokenData::_internal_set_max_supply(const std::string& value) {
  
  max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenData::_internal_mutable_max_supply() {
  
  return max_supply_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenData::release_max_supply() {
  // @@protoc_insertion_point(field_release:api_pb.CreateTokenData.max_supply)
  return max_supply_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenData::set_allocated_max_supply(std::string* max_supply) {
  if (max_supply != nullptr) {
    
  } else {
    
  }
  max_supply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_supply,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.CreateTokenData.max_supply)
}

// bool mintable = 5 [json_name = "mintable"];
inline void CreateTokenData::clear_mintable() {
  mintable_ = false;
}
inline bool CreateTokenData::_internal_mintable() const {
  return mintable_;
}
inline bool CreateTokenData::mintable() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.mintable)
  return _internal_mintable();
}
inline void CreateTokenData::_internal_set_mintable(bool value) {
  
  mintable_ = value;
}
inline void CreateTokenData::set_mintable(bool value) {
  _internal_set_mintable(value);
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.mintable)
}

// bool burnable = 6 [json_name = "burnable"];
inline void CreateTokenData::clear_burnable() {
  burnable_ = false;
}
inline bool CreateTokenData::_internal_burnable() const {
  return burnable_;
}
inline bool CreateTokenData::burnable() const {
  // @@protoc_insertion_point(field_get:api_pb.CreateTokenData.burnable)
  return _internal_burnable();
}
inline void CreateTokenData::_internal_set_burnable(bool value) {
  
  burnable_ = value;
}
inline void CreateTokenData::set_burnable(bool value) {
  _internal_set_burnable(value);
  // @@protoc_insertion_point(field_set:api_pb.CreateTokenData.burnable)
}

// -------------------------------------------------------------------

// RecreateTokenData

// string name = 1 [json_name = "name"];
inline void RecreateTokenData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RecreateTokenData::name() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateTokenData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.name)
}
inline std::string* RecreateTokenData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateTokenData.name)
  return _s;
}
inline const std::string& RecreateTokenData::_internal_name() const {
  return name_.Get();
}
inline void RecreateTokenData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::release_name() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateTokenData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateTokenData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateTokenData.name)
}

// string symbol = 2 [json_name = "symbol"];
inline void RecreateTokenData::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& RecreateTokenData::symbol() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateTokenData::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.symbol)
}
inline std::string* RecreateTokenData::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateTokenData.symbol)
  return _s;
}
inline const std::string& RecreateTokenData::_internal_symbol() const {
  return symbol_.Get();
}
inline void RecreateTokenData::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::release_symbol() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateTokenData.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateTokenData::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateTokenData.symbol)
}

// string initial_amount = 3 [json_name = "initialAmount"];
inline void RecreateTokenData::clear_initial_amount() {
  initial_amount_.ClearToEmpty();
}
inline const std::string& RecreateTokenData::initial_amount() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.initial_amount)
  return _internal_initial_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateTokenData::set_initial_amount(ArgT0&& arg0, ArgT... args) {
 
 initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.initial_amount)
}
inline std::string* RecreateTokenData::mutable_initial_amount() {
  std::string* _s = _internal_mutable_initial_amount();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateTokenData.initial_amount)
  return _s;
}
inline const std::string& RecreateTokenData::_internal_initial_amount() const {
  return initial_amount_.Get();
}
inline void RecreateTokenData::_internal_set_initial_amount(const std::string& value) {
  
  initial_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::_internal_mutable_initial_amount() {
  
  return initial_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::release_initial_amount() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateTokenData.initial_amount)
  return initial_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateTokenData::set_allocated_initial_amount(std::string* initial_amount) {
  if (initial_amount != nullptr) {
    
  } else {
    
  }
  initial_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateTokenData.initial_amount)
}

// string max_supply = 4 [json_name = "maxSupply"];
inline void RecreateTokenData::clear_max_supply() {
  max_supply_.ClearToEmpty();
}
inline const std::string& RecreateTokenData::max_supply() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.max_supply)
  return _internal_max_supply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecreateTokenData::set_max_supply(ArgT0&& arg0, ArgT... args) {
 
 max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.max_supply)
}
inline std::string* RecreateTokenData::mutable_max_supply() {
  std::string* _s = _internal_mutable_max_supply();
  // @@protoc_insertion_point(field_mutable:api_pb.RecreateTokenData.max_supply)
  return _s;
}
inline const std::string& RecreateTokenData::_internal_max_supply() const {
  return max_supply_.Get();
}
inline void RecreateTokenData::_internal_set_max_supply(const std::string& value) {
  
  max_supply_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::_internal_mutable_max_supply() {
  
  return max_supply_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecreateTokenData::release_max_supply() {
  // @@protoc_insertion_point(field_release:api_pb.RecreateTokenData.max_supply)
  return max_supply_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecreateTokenData::set_allocated_max_supply(std::string* max_supply) {
  if (max_supply != nullptr) {
    
  } else {
    
  }
  max_supply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_supply,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.RecreateTokenData.max_supply)
}

// bool mintable = 5 [json_name = "mintable"];
inline void RecreateTokenData::clear_mintable() {
  mintable_ = false;
}
inline bool RecreateTokenData::_internal_mintable() const {
  return mintable_;
}
inline bool RecreateTokenData::mintable() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.mintable)
  return _internal_mintable();
}
inline void RecreateTokenData::_internal_set_mintable(bool value) {
  
  mintable_ = value;
}
inline void RecreateTokenData::set_mintable(bool value) {
  _internal_set_mintable(value);
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.mintable)
}

// bool burnable = 6 [json_name = "burnable"];
inline void RecreateTokenData::clear_burnable() {
  burnable_ = false;
}
inline bool RecreateTokenData::_internal_burnable() const {
  return burnable_;
}
inline bool RecreateTokenData::burnable() const {
  // @@protoc_insertion_point(field_get:api_pb.RecreateTokenData.burnable)
  return _internal_burnable();
}
inline void RecreateTokenData::_internal_set_burnable(bool value) {
  
  burnable_ = value;
}
inline void RecreateTokenData::set_burnable(bool value) {
  _internal_set_burnable(value);
  // @@protoc_insertion_point(field_set:api_pb.RecreateTokenData.burnable)
}

// -------------------------------------------------------------------

// VoteCommissionData

// string pub_key = 1 [json_name = "pubKey"];
inline void VoteCommissionData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.pub_key)
}
inline std::string* VoteCommissionData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.pub_key)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void VoteCommissionData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.pub_key)
}

// uint64 height = 2 [json_name = "height"];
inline void VoteCommissionData::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VoteCommissionData::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VoteCommissionData::height() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.height)
  return _internal_height();
}
inline void VoteCommissionData::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void VoteCommissionData::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.height)
}

// .api_pb.Coin coin = 3 [json_name = "coin"];
inline bool VoteCommissionData::_internal_has_coin() const {
  return this != internal_default_instance() && coin_ != nullptr;
}
inline bool VoteCommissionData::has_coin() const {
  return _internal_has_coin();
}
inline const ::api_pb::Coin& VoteCommissionData::_internal_coin() const {
  const ::api_pb::Coin* p = coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& VoteCommissionData::coin() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.coin)
  return _internal_coin();
}
inline void VoteCommissionData::unsafe_arena_set_allocated_coin(
    ::api_pb::Coin* coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  coin_ = coin;
  if (coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.VoteCommissionData.coin)
}
inline ::api_pb::Coin* VoteCommissionData::release_coin() {
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* VoteCommissionData::unsafe_arena_release_coin() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.coin)
  
  ::api_pb::Coin* temp = coin_;
  coin_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* VoteCommissionData::_internal_mutable_coin() {
  
  if (coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_ = p;
  }
  return coin_;
}
inline ::api_pb::Coin* VoteCommissionData::mutable_coin() {
  ::api_pb::Coin* _msg = _internal_mutable_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.coin)
  return _msg;
}
inline void VoteCommissionData::set_allocated_coin(::api_pb::Coin* coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_);
  }
  if (coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin));
    if (message_arena != submessage_arena) {
      coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin, submessage_arena);
    }
    
  } else {
    
  }
  coin_ = coin;
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.coin)
}

// string payload_byte = 4 [json_name = "payloadByte"];
inline void VoteCommissionData::clear_payload_byte() {
  payload_byte_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::payload_byte() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.payload_byte)
  return _internal_payload_byte();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_payload_byte(ArgT0&& arg0, ArgT... args) {
 
 payload_byte_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.payload_byte)
}
inline std::string* VoteCommissionData::mutable_payload_byte() {
  std::string* _s = _internal_mutable_payload_byte();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.payload_byte)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_payload_byte() const {
  return payload_byte_.Get();
}
inline void VoteCommissionData::_internal_set_payload_byte(const std::string& value) {
  
  payload_byte_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_payload_byte() {
  
  return payload_byte_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_payload_byte() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.payload_byte)
  return payload_byte_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_payload_byte(std::string* payload_byte) {
  if (payload_byte != nullptr) {
    
  } else {
    
  }
  payload_byte_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload_byte,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.payload_byte)
}

// string send = 5 [json_name = "send"];
inline void VoteCommissionData::clear_send() {
  send_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::send() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.send)
  return _internal_send();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_send(ArgT0&& arg0, ArgT... args) {
 
 send_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.send)
}
inline std::string* VoteCommissionData::mutable_send() {
  std::string* _s = _internal_mutable_send();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.send)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_send() const {
  return send_.Get();
}
inline void VoteCommissionData::_internal_set_send(const std::string& value) {
  
  send_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_send() {
  
  return send_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_send() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.send)
  return send_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_send(std::string* send) {
  if (send != nullptr) {
    
  } else {
    
  }
  send_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), send,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.send)
}

// string buy_bancor = 38 [json_name = "buyBancor"];
inline void VoteCommissionData::clear_buy_bancor() {
  buy_bancor_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::buy_bancor() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.buy_bancor)
  return _internal_buy_bancor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_buy_bancor(ArgT0&& arg0, ArgT... args) {
 
 buy_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.buy_bancor)
}
inline std::string* VoteCommissionData::mutable_buy_bancor() {
  std::string* _s = _internal_mutable_buy_bancor();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.buy_bancor)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_buy_bancor() const {
  return buy_bancor_.Get();
}
inline void VoteCommissionData::_internal_set_buy_bancor(const std::string& value) {
  
  buy_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_buy_bancor() {
  
  return buy_bancor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_buy_bancor() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.buy_bancor)
  return buy_bancor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_buy_bancor(std::string* buy_bancor) {
  if (buy_bancor != nullptr) {
    
  } else {
    
  }
  buy_bancor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_bancor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.buy_bancor)
}

// string sell_bancor = 39 [json_name = "sellBancor"];
inline void VoteCommissionData::clear_sell_bancor() {
  sell_bancor_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_bancor() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_bancor)
  return _internal_sell_bancor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_bancor(ArgT0&& arg0, ArgT... args) {
 
 sell_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_bancor)
}
inline std::string* VoteCommissionData::mutable_sell_bancor() {
  std::string* _s = _internal_mutable_sell_bancor();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_bancor)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_bancor() const {
  return sell_bancor_.Get();
}
inline void VoteCommissionData::_internal_set_sell_bancor(const std::string& value) {
  
  sell_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_bancor() {
  
  return sell_bancor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_bancor() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_bancor)
  return sell_bancor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_bancor(std::string* sell_bancor) {
  if (sell_bancor != nullptr) {
    
  } else {
    
  }
  sell_bancor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_bancor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_bancor)
}

// string sell_all_bancor = 40 [json_name = "sellAllBancor"];
inline void VoteCommissionData::clear_sell_all_bancor() {
  sell_all_bancor_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_all_bancor() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_all_bancor)
  return _internal_sell_all_bancor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_all_bancor(ArgT0&& arg0, ArgT... args) {
 
 sell_all_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_all_bancor)
}
inline std::string* VoteCommissionData::mutable_sell_all_bancor() {
  std::string* _s = _internal_mutable_sell_all_bancor();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_all_bancor)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_all_bancor() const {
  return sell_all_bancor_.Get();
}
inline void VoteCommissionData::_internal_set_sell_all_bancor(const std::string& value) {
  
  sell_all_bancor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_all_bancor() {
  
  return sell_all_bancor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_all_bancor() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_all_bancor)
  return sell_all_bancor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_all_bancor(std::string* sell_all_bancor) {
  if (sell_all_bancor != nullptr) {
    
  } else {
    
  }
  sell_all_bancor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_all_bancor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_all_bancor)
}

// string buy_pool_base = 41 [json_name = "buyPoolBase"];
inline void VoteCommissionData::clear_buy_pool_base() {
  buy_pool_base_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::buy_pool_base() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.buy_pool_base)
  return _internal_buy_pool_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_buy_pool_base(ArgT0&& arg0, ArgT... args) {
 
 buy_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.buy_pool_base)
}
inline std::string* VoteCommissionData::mutable_buy_pool_base() {
  std::string* _s = _internal_mutable_buy_pool_base();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.buy_pool_base)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_buy_pool_base() const {
  return buy_pool_base_.Get();
}
inline void VoteCommissionData::_internal_set_buy_pool_base(const std::string& value) {
  
  buy_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_buy_pool_base() {
  
  return buy_pool_base_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_buy_pool_base() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.buy_pool_base)
  return buy_pool_base_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_buy_pool_base(std::string* buy_pool_base) {
  if (buy_pool_base != nullptr) {
    
  } else {
    
  }
  buy_pool_base_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_pool_base,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.buy_pool_base)
}

// string buy_pool_delta = 53 [json_name = "buyPoolDelta"];
inline void VoteCommissionData::clear_buy_pool_delta() {
  buy_pool_delta_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::buy_pool_delta() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.buy_pool_delta)
  return _internal_buy_pool_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_buy_pool_delta(ArgT0&& arg0, ArgT... args) {
 
 buy_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.buy_pool_delta)
}
inline std::string* VoteCommissionData::mutable_buy_pool_delta() {
  std::string* _s = _internal_mutable_buy_pool_delta();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.buy_pool_delta)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_buy_pool_delta() const {
  return buy_pool_delta_.Get();
}
inline void VoteCommissionData::_internal_set_buy_pool_delta(const std::string& value) {
  
  buy_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_buy_pool_delta() {
  
  return buy_pool_delta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_buy_pool_delta() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.buy_pool_delta)
  return buy_pool_delta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_buy_pool_delta(std::string* buy_pool_delta) {
  if (buy_pool_delta != nullptr) {
    
  } else {
    
  }
  buy_pool_delta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_pool_delta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.buy_pool_delta)
}

// string sell_pool_base = 42 [json_name = "sellPoolBase"];
inline void VoteCommissionData::clear_sell_pool_base() {
  sell_pool_base_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_pool_base() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_pool_base)
  return _internal_sell_pool_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_pool_base(ArgT0&& arg0, ArgT... args) {
 
 sell_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_pool_base)
}
inline std::string* VoteCommissionData::mutable_sell_pool_base() {
  std::string* _s = _internal_mutable_sell_pool_base();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_pool_base)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_pool_base() const {
  return sell_pool_base_.Get();
}
inline void VoteCommissionData::_internal_set_sell_pool_base(const std::string& value) {
  
  sell_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_pool_base() {
  
  return sell_pool_base_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_pool_base() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_pool_base)
  return sell_pool_base_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_pool_base(std::string* sell_pool_base) {
  if (sell_pool_base != nullptr) {
    
  } else {
    
  }
  sell_pool_base_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_pool_base,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_pool_base)
}

// string sell_pool_delta = 54 [json_name = "sellPoolDelta"];
inline void VoteCommissionData::clear_sell_pool_delta() {
  sell_pool_delta_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_pool_delta() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_pool_delta)
  return _internal_sell_pool_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_pool_delta(ArgT0&& arg0, ArgT... args) {
 
 sell_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_pool_delta)
}
inline std::string* VoteCommissionData::mutable_sell_pool_delta() {
  std::string* _s = _internal_mutable_sell_pool_delta();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_pool_delta)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_pool_delta() const {
  return sell_pool_delta_.Get();
}
inline void VoteCommissionData::_internal_set_sell_pool_delta(const std::string& value) {
  
  sell_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_pool_delta() {
  
  return sell_pool_delta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_pool_delta() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_pool_delta)
  return sell_pool_delta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_pool_delta(std::string* sell_pool_delta) {
  if (sell_pool_delta != nullptr) {
    
  } else {
    
  }
  sell_pool_delta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_pool_delta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_pool_delta)
}

// string sell_all_pool_base = 43 [json_name = "sellAllPoolBase"];
inline void VoteCommissionData::clear_sell_all_pool_base() {
  sell_all_pool_base_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_all_pool_base() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_all_pool_base)
  return _internal_sell_all_pool_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_all_pool_base(ArgT0&& arg0, ArgT... args) {
 
 sell_all_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_all_pool_base)
}
inline std::string* VoteCommissionData::mutable_sell_all_pool_base() {
  std::string* _s = _internal_mutable_sell_all_pool_base();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_all_pool_base)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_all_pool_base() const {
  return sell_all_pool_base_.Get();
}
inline void VoteCommissionData::_internal_set_sell_all_pool_base(const std::string& value) {
  
  sell_all_pool_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_all_pool_base() {
  
  return sell_all_pool_base_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_all_pool_base() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_all_pool_base)
  return sell_all_pool_base_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_all_pool_base(std::string* sell_all_pool_base) {
  if (sell_all_pool_base != nullptr) {
    
  } else {
    
  }
  sell_all_pool_base_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_all_pool_base,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_all_pool_base)
}

// string sell_all_pool_delta = 55 [json_name = "sellAllPoolDelta"];
inline void VoteCommissionData::clear_sell_all_pool_delta() {
  sell_all_pool_delta_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::sell_all_pool_delta() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.sell_all_pool_delta)
  return _internal_sell_all_pool_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_sell_all_pool_delta(ArgT0&& arg0, ArgT... args) {
 
 sell_all_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.sell_all_pool_delta)
}
inline std::string* VoteCommissionData::mutable_sell_all_pool_delta() {
  std::string* _s = _internal_mutable_sell_all_pool_delta();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.sell_all_pool_delta)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_sell_all_pool_delta() const {
  return sell_all_pool_delta_.Get();
}
inline void VoteCommissionData::_internal_set_sell_all_pool_delta(const std::string& value) {
  
  sell_all_pool_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_sell_all_pool_delta() {
  
  return sell_all_pool_delta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_sell_all_pool_delta() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.sell_all_pool_delta)
  return sell_all_pool_delta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_sell_all_pool_delta(std::string* sell_all_pool_delta) {
  if (sell_all_pool_delta != nullptr) {
    
  } else {
    
  }
  sell_all_pool_delta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_all_pool_delta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.sell_all_pool_delta)
}

// string create_ticker3 = 7 [json_name = "createTicker3"];
inline void VoteCommissionData::clear_create_ticker3() {
  create_ticker3_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_ticker3() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_ticker3)
  return _internal_create_ticker3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_ticker3(ArgT0&& arg0, ArgT... args) {
 
 create_ticker3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_ticker3)
}
inline std::string* VoteCommissionData::mutable_create_ticker3() {
  std::string* _s = _internal_mutable_create_ticker3();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_ticker3)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_ticker3() const {
  return create_ticker3_.Get();
}
inline void VoteCommissionData::_internal_set_create_ticker3(const std::string& value) {
  
  create_ticker3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_ticker3() {
  
  return create_ticker3_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_ticker3() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_ticker3)
  return create_ticker3_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_ticker3(std::string* create_ticker3) {
  if (create_ticker3 != nullptr) {
    
  } else {
    
  }
  create_ticker3_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_ticker3,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_ticker3)
}

// string create_ticker4 = 8 [json_name = "createTicker4"];
inline void VoteCommissionData::clear_create_ticker4() {
  create_ticker4_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_ticker4() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_ticker4)
  return _internal_create_ticker4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_ticker4(ArgT0&& arg0, ArgT... args) {
 
 create_ticker4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_ticker4)
}
inline std::string* VoteCommissionData::mutable_create_ticker4() {
  std::string* _s = _internal_mutable_create_ticker4();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_ticker4)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_ticker4() const {
  return create_ticker4_.Get();
}
inline void VoteCommissionData::_internal_set_create_ticker4(const std::string& value) {
  
  create_ticker4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_ticker4() {
  
  return create_ticker4_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_ticker4() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_ticker4)
  return create_ticker4_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_ticker4(std::string* create_ticker4) {
  if (create_ticker4 != nullptr) {
    
  } else {
    
  }
  create_ticker4_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_ticker4,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_ticker4)
}

// string create_ticker5 = 9 [json_name = "createTicker5"];
inline void VoteCommissionData::clear_create_ticker5() {
  create_ticker5_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_ticker5() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_ticker5)
  return _internal_create_ticker5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_ticker5(ArgT0&& arg0, ArgT... args) {
 
 create_ticker5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_ticker5)
}
inline std::string* VoteCommissionData::mutable_create_ticker5() {
  std::string* _s = _internal_mutable_create_ticker5();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_ticker5)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_ticker5() const {
  return create_ticker5_.Get();
}
inline void VoteCommissionData::_internal_set_create_ticker5(const std::string& value) {
  
  create_ticker5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_ticker5() {
  
  return create_ticker5_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_ticker5() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_ticker5)
  return create_ticker5_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_ticker5(std::string* create_ticker5) {
  if (create_ticker5 != nullptr) {
    
  } else {
    
  }
  create_ticker5_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_ticker5,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_ticker5)
}

// string create_ticker6 = 10 [json_name = "createTicker6"];
inline void VoteCommissionData::clear_create_ticker6() {
  create_ticker6_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_ticker6() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_ticker6)
  return _internal_create_ticker6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_ticker6(ArgT0&& arg0, ArgT... args) {
 
 create_ticker6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_ticker6)
}
inline std::string* VoteCommissionData::mutable_create_ticker6() {
  std::string* _s = _internal_mutable_create_ticker6();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_ticker6)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_ticker6() const {
  return create_ticker6_.Get();
}
inline void VoteCommissionData::_internal_set_create_ticker6(const std::string& value) {
  
  create_ticker6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_ticker6() {
  
  return create_ticker6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_ticker6() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_ticker6)
  return create_ticker6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_ticker6(std::string* create_ticker6) {
  if (create_ticker6 != nullptr) {
    
  } else {
    
  }
  create_ticker6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_ticker6,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_ticker6)
}

// string create_ticker7_10 = 11 [json_name = "createTicker710"];
inline void VoteCommissionData::clear_create_ticker7_10() {
  create_ticker7_10_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_ticker7_10() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_ticker7_10)
  return _internal_create_ticker7_10();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_ticker7_10(ArgT0&& arg0, ArgT... args) {
 
 create_ticker7_10_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_ticker7_10)
}
inline std::string* VoteCommissionData::mutable_create_ticker7_10() {
  std::string* _s = _internal_mutable_create_ticker7_10();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_ticker7_10)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_ticker7_10() const {
  return create_ticker7_10_.Get();
}
inline void VoteCommissionData::_internal_set_create_ticker7_10(const std::string& value) {
  
  create_ticker7_10_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_ticker7_10() {
  
  return create_ticker7_10_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_ticker7_10() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_ticker7_10)
  return create_ticker7_10_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_ticker7_10(std::string* create_ticker7_10) {
  if (create_ticker7_10 != nullptr) {
    
  } else {
    
  }
  create_ticker7_10_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_ticker7_10,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_ticker7_10)
}

// string create_coin = 34 [json_name = "createCoin"];
inline void VoteCommissionData::clear_create_coin() {
  create_coin_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_coin() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_coin)
  return _internal_create_coin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_coin(ArgT0&& arg0, ArgT... args) {
 
 create_coin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_coin)
}
inline std::string* VoteCommissionData::mutable_create_coin() {
  std::string* _s = _internal_mutable_create_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_coin)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_coin() const {
  return create_coin_.Get();
}
inline void VoteCommissionData::_internal_set_create_coin(const std::string& value) {
  
  create_coin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_coin() {
  
  return create_coin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_coin() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_coin)
  return create_coin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_coin(std::string* create_coin) {
  if (create_coin != nullptr) {
    
  } else {
    
  }
  create_coin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_coin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_coin)
}

// string create_token = 35 [json_name = "createToken"];
inline void VoteCommissionData::clear_create_token() {
  create_token_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_token() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_token)
  return _internal_create_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_token(ArgT0&& arg0, ArgT... args) {
 
 create_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_token)
}
inline std::string* VoteCommissionData::mutable_create_token() {
  std::string* _s = _internal_mutable_create_token();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_token)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_token() const {
  return create_token_.Get();
}
inline void VoteCommissionData::_internal_set_create_token(const std::string& value) {
  
  create_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_token() {
  
  return create_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_token() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_token)
  return create_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_token(std::string* create_token) {
  if (create_token != nullptr) {
    
  } else {
    
  }
  create_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_token)
}

// string recreate_coin = 36 [json_name = "recreateCoin"];
inline void VoteCommissionData::clear_recreate_coin() {
  recreate_coin_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::recreate_coin() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.recreate_coin)
  return _internal_recreate_coin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_recreate_coin(ArgT0&& arg0, ArgT... args) {
 
 recreate_coin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.recreate_coin)
}
inline std::string* VoteCommissionData::mutable_recreate_coin() {
  std::string* _s = _internal_mutable_recreate_coin();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.recreate_coin)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_recreate_coin() const {
  return recreate_coin_.Get();
}
inline void VoteCommissionData::_internal_set_recreate_coin(const std::string& value) {
  
  recreate_coin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_recreate_coin() {
  
  return recreate_coin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_recreate_coin() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.recreate_coin)
  return recreate_coin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_recreate_coin(std::string* recreate_coin) {
  if (recreate_coin != nullptr) {
    
  } else {
    
  }
  recreate_coin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recreate_coin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.recreate_coin)
}

// string recreate_token = 37 [json_name = "recreateToken"];
inline void VoteCommissionData::clear_recreate_token() {
  recreate_token_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::recreate_token() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.recreate_token)
  return _internal_recreate_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_recreate_token(ArgT0&& arg0, ArgT... args) {
 
 recreate_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.recreate_token)
}
inline std::string* VoteCommissionData::mutable_recreate_token() {
  std::string* _s = _internal_mutable_recreate_token();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.recreate_token)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_recreate_token() const {
  return recreate_token_.Get();
}
inline void VoteCommissionData::_internal_set_recreate_token(const std::string& value) {
  
  recreate_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_recreate_token() {
  
  return recreate_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_recreate_token() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.recreate_token)
  return recreate_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_recreate_token(std::string* recreate_token) {
  if (recreate_token != nullptr) {
    
  } else {
    
  }
  recreate_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recreate_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.recreate_token)
}

// string declare_candidacy = 13 [json_name = "declareCandidacy"];
inline void VoteCommissionData::clear_declare_candidacy() {
  declare_candidacy_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::declare_candidacy() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.declare_candidacy)
  return _internal_declare_candidacy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_declare_candidacy(ArgT0&& arg0, ArgT... args) {
 
 declare_candidacy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.declare_candidacy)
}
inline std::string* VoteCommissionData::mutable_declare_candidacy() {
  std::string* _s = _internal_mutable_declare_candidacy();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.declare_candidacy)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_declare_candidacy() const {
  return declare_candidacy_.Get();
}
inline void VoteCommissionData::_internal_set_declare_candidacy(const std::string& value) {
  
  declare_candidacy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_declare_candidacy() {
  
  return declare_candidacy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_declare_candidacy() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.declare_candidacy)
  return declare_candidacy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_declare_candidacy(std::string* declare_candidacy) {
  if (declare_candidacy != nullptr) {
    
  } else {
    
  }
  declare_candidacy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), declare_candidacy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.declare_candidacy)
}

// string delegate = 14 [json_name = "delegate"];
inline void VoteCommissionData::clear_delegate() {
  delegate_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::delegate() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.delegate)
  return _internal_delegate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_delegate(ArgT0&& arg0, ArgT... args) {
 
 delegate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.delegate)
}
inline std::string* VoteCommissionData::mutable_delegate() {
  std::string* _s = _internal_mutable_delegate();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.delegate)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_delegate() const {
  return delegate_.Get();
}
inline void VoteCommissionData::_internal_set_delegate(const std::string& value) {
  
  delegate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_delegate() {
  
  return delegate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_delegate() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.delegate)
  return delegate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_delegate(std::string* delegate) {
  if (delegate != nullptr) {
    
  } else {
    
  }
  delegate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), delegate,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.delegate)
}

// string unbond = 15 [json_name = "unbond"];
inline void VoteCommissionData::clear_unbond() {
  unbond_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::unbond() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.unbond)
  return _internal_unbond();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_unbond(ArgT0&& arg0, ArgT... args) {
 
 unbond_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.unbond)
}
inline std::string* VoteCommissionData::mutable_unbond() {
  std::string* _s = _internal_mutable_unbond();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.unbond)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_unbond() const {
  return unbond_.Get();
}
inline void VoteCommissionData::_internal_set_unbond(const std::string& value) {
  
  unbond_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_unbond() {
  
  return unbond_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_unbond() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.unbond)
  return unbond_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_unbond(std::string* unbond) {
  if (unbond != nullptr) {
    
  } else {
    
  }
  unbond_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unbond,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.unbond)
}

// string redeem_check = 16 [json_name = "redeemCheck"];
inline void VoteCommissionData::clear_redeem_check() {
  redeem_check_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::redeem_check() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.redeem_check)
  return _internal_redeem_check();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_redeem_check(ArgT0&& arg0, ArgT... args) {
 
 redeem_check_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.redeem_check)
}
inline std::string* VoteCommissionData::mutable_redeem_check() {
  std::string* _s = _internal_mutable_redeem_check();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.redeem_check)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_redeem_check() const {
  return redeem_check_.Get();
}
inline void VoteCommissionData::_internal_set_redeem_check(const std::string& value) {
  
  redeem_check_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_redeem_check() {
  
  return redeem_check_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_redeem_check() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.redeem_check)
  return redeem_check_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_redeem_check(std::string* redeem_check) {
  if (redeem_check != nullptr) {
    
  } else {
    
  }
  redeem_check_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), redeem_check,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.redeem_check)
}

// string set_candidate_on = 44 [json_name = "setCandidateOn"];
inline void VoteCommissionData::clear_set_candidate_on() {
  set_candidate_on_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::set_candidate_on() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.set_candidate_on)
  return _internal_set_candidate_on();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_set_candidate_on(ArgT0&& arg0, ArgT... args) {
 
 set_candidate_on_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.set_candidate_on)
}
inline std::string* VoteCommissionData::mutable_set_candidate_on() {
  std::string* _s = _internal_mutable_set_candidate_on();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.set_candidate_on)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_set_candidate_on() const {
  return set_candidate_on_.Get();
}
inline void VoteCommissionData::_internal_set_set_candidate_on(const std::string& value) {
  
  set_candidate_on_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_set_candidate_on() {
  
  return set_candidate_on_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_set_candidate_on() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.set_candidate_on)
  return set_candidate_on_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_set_candidate_on(std::string* set_candidate_on) {
  if (set_candidate_on != nullptr) {
    
  } else {
    
  }
  set_candidate_on_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_candidate_on,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.set_candidate_on)
}

// string set_candidate_off = 45 [json_name = "setCandidateOff"];
inline void VoteCommissionData::clear_set_candidate_off() {
  set_candidate_off_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::set_candidate_off() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.set_candidate_off)
  return _internal_set_candidate_off();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_set_candidate_off(ArgT0&& arg0, ArgT... args) {
 
 set_candidate_off_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.set_candidate_off)
}
inline std::string* VoteCommissionData::mutable_set_candidate_off() {
  std::string* _s = _internal_mutable_set_candidate_off();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.set_candidate_off)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_set_candidate_off() const {
  return set_candidate_off_.Get();
}
inline void VoteCommissionData::_internal_set_set_candidate_off(const std::string& value) {
  
  set_candidate_off_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_set_candidate_off() {
  
  return set_candidate_off_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_set_candidate_off() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.set_candidate_off)
  return set_candidate_off_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_set_candidate_off(std::string* set_candidate_off) {
  if (set_candidate_off != nullptr) {
    
  } else {
    
  }
  set_candidate_off_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_candidate_off,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.set_candidate_off)
}

// string create_multisig = 18 [json_name = "createMultisig"];
inline void VoteCommissionData::clear_create_multisig() {
  create_multisig_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_multisig() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_multisig)
  return _internal_create_multisig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_multisig(ArgT0&& arg0, ArgT... args) {
 
 create_multisig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_multisig)
}
inline std::string* VoteCommissionData::mutable_create_multisig() {
  std::string* _s = _internal_mutable_create_multisig();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_multisig)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_multisig() const {
  return create_multisig_.Get();
}
inline void VoteCommissionData::_internal_set_create_multisig(const std::string& value) {
  
  create_multisig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_multisig() {
  
  return create_multisig_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_multisig() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_multisig)
  return create_multisig_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_multisig(std::string* create_multisig) {
  if (create_multisig != nullptr) {
    
  } else {
    
  }
  create_multisig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_multisig,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_multisig)
}

// string multisend_base = 51 [json_name = "multisendBase"];
inline void VoteCommissionData::clear_multisend_base() {
  multisend_base_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::multisend_base() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.multisend_base)
  return _internal_multisend_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_multisend_base(ArgT0&& arg0, ArgT... args) {
 
 multisend_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.multisend_base)
}
inline std::string* VoteCommissionData::mutable_multisend_base() {
  std::string* _s = _internal_mutable_multisend_base();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.multisend_base)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_multisend_base() const {
  return multisend_base_.Get();
}
inline void VoteCommissionData::_internal_set_multisend_base(const std::string& value) {
  
  multisend_base_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_multisend_base() {
  
  return multisend_base_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_multisend_base() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.multisend_base)
  return multisend_base_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_multisend_base(std::string* multisend_base) {
  if (multisend_base != nullptr) {
    
  } else {
    
  }
  multisend_base_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multisend_base,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.multisend_base)
}

// string multisend_delta = 52 [json_name = "multisendDelta"];
inline void VoteCommissionData::clear_multisend_delta() {
  multisend_delta_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::multisend_delta() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.multisend_delta)
  return _internal_multisend_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_multisend_delta(ArgT0&& arg0, ArgT... args) {
 
 multisend_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.multisend_delta)
}
inline std::string* VoteCommissionData::mutable_multisend_delta() {
  std::string* _s = _internal_mutable_multisend_delta();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.multisend_delta)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_multisend_delta() const {
  return multisend_delta_.Get();
}
inline void VoteCommissionData::_internal_set_multisend_delta(const std::string& value) {
  
  multisend_delta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_multisend_delta() {
  
  return multisend_delta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_multisend_delta() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.multisend_delta)
  return multisend_delta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_multisend_delta(std::string* multisend_delta) {
  if (multisend_delta != nullptr) {
    
  } else {
    
  }
  multisend_delta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multisend_delta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.multisend_delta)
}

// string edit_candidate = 20 [json_name = "editCandidate"];
inline void VoteCommissionData::clear_edit_candidate() {
  edit_candidate_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::edit_candidate() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.edit_candidate)
  return _internal_edit_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_edit_candidate(ArgT0&& arg0, ArgT... args) {
 
 edit_candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.edit_candidate)
}
inline std::string* VoteCommissionData::mutable_edit_candidate() {
  std::string* _s = _internal_mutable_edit_candidate();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.edit_candidate)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_edit_candidate() const {
  return edit_candidate_.Get();
}
inline void VoteCommissionData::_internal_set_edit_candidate(const std::string& value) {
  
  edit_candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_edit_candidate() {
  
  return edit_candidate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_edit_candidate() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.edit_candidate)
  return edit_candidate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_edit_candidate(std::string* edit_candidate) {
  if (edit_candidate != nullptr) {
    
  } else {
    
  }
  edit_candidate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edit_candidate,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.edit_candidate)
}

// string set_halt_block = 21 [json_name = "setHaltBlock"];
inline void VoteCommissionData::clear_set_halt_block() {
  set_halt_block_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::set_halt_block() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.set_halt_block)
  return _internal_set_halt_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_set_halt_block(ArgT0&& arg0, ArgT... args) {
 
 set_halt_block_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.set_halt_block)
}
inline std::string* VoteCommissionData::mutable_set_halt_block() {
  std::string* _s = _internal_mutable_set_halt_block();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.set_halt_block)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_set_halt_block() const {
  return set_halt_block_.Get();
}
inline void VoteCommissionData::_internal_set_set_halt_block(const std::string& value) {
  
  set_halt_block_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_set_halt_block() {
  
  return set_halt_block_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_set_halt_block() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.set_halt_block)
  return set_halt_block_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_set_halt_block(std::string* set_halt_block) {
  if (set_halt_block != nullptr) {
    
  } else {
    
  }
  set_halt_block_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_halt_block,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.set_halt_block)
}

// string edit_ticker_owner = 22 [json_name = "editTickerOwner"];
inline void VoteCommissionData::clear_edit_ticker_owner() {
  edit_ticker_owner_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::edit_ticker_owner() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.edit_ticker_owner)
  return _internal_edit_ticker_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_edit_ticker_owner(ArgT0&& arg0, ArgT... args) {
 
 edit_ticker_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.edit_ticker_owner)
}
inline std::string* VoteCommissionData::mutable_edit_ticker_owner() {
  std::string* _s = _internal_mutable_edit_ticker_owner();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.edit_ticker_owner)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_edit_ticker_owner() const {
  return edit_ticker_owner_.Get();
}
inline void VoteCommissionData::_internal_set_edit_ticker_owner(const std::string& value) {
  
  edit_ticker_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_edit_ticker_owner() {
  
  return edit_ticker_owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_edit_ticker_owner() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.edit_ticker_owner)
  return edit_ticker_owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_edit_ticker_owner(std::string* edit_ticker_owner) {
  if (edit_ticker_owner != nullptr) {
    
  } else {
    
  }
  edit_ticker_owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edit_ticker_owner,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.edit_ticker_owner)
}

// string edit_multisig = 23 [json_name = "editMultisig"];
inline void VoteCommissionData::clear_edit_multisig() {
  edit_multisig_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::edit_multisig() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.edit_multisig)
  return _internal_edit_multisig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_edit_multisig(ArgT0&& arg0, ArgT... args) {
 
 edit_multisig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.edit_multisig)
}
inline std::string* VoteCommissionData::mutable_edit_multisig() {
  std::string* _s = _internal_mutable_edit_multisig();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.edit_multisig)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_edit_multisig() const {
  return edit_multisig_.Get();
}
inline void VoteCommissionData::_internal_set_edit_multisig(const std::string& value) {
  
  edit_multisig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_edit_multisig() {
  
  return edit_multisig_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_edit_multisig() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.edit_multisig)
  return edit_multisig_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_edit_multisig(std::string* edit_multisig) {
  if (edit_multisig != nullptr) {
    
  } else {
    
  }
  edit_multisig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edit_multisig,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.edit_multisig)
}

// string edit_candidate_public_key = 25 [json_name = "editCandidatePublicKey"];
inline void VoteCommissionData::clear_edit_candidate_public_key() {
  edit_candidate_public_key_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::edit_candidate_public_key() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.edit_candidate_public_key)
  return _internal_edit_candidate_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_edit_candidate_public_key(ArgT0&& arg0, ArgT... args) {
 
 edit_candidate_public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.edit_candidate_public_key)
}
inline std::string* VoteCommissionData::mutable_edit_candidate_public_key() {
  std::string* _s = _internal_mutable_edit_candidate_public_key();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.edit_candidate_public_key)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_edit_candidate_public_key() const {
  return edit_candidate_public_key_.Get();
}
inline void VoteCommissionData::_internal_set_edit_candidate_public_key(const std::string& value) {
  
  edit_candidate_public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_edit_candidate_public_key() {
  
  return edit_candidate_public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_edit_candidate_public_key() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.edit_candidate_public_key)
  return edit_candidate_public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_edit_candidate_public_key(std::string* edit_candidate_public_key) {
  if (edit_candidate_public_key != nullptr) {
    
  } else {
    
  }
  edit_candidate_public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edit_candidate_public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.edit_candidate_public_key)
}

// string create_swap_pool = 48 [json_name = "createSwapPool"];
inline void VoteCommissionData::clear_create_swap_pool() {
  create_swap_pool_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::create_swap_pool() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.create_swap_pool)
  return _internal_create_swap_pool();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_create_swap_pool(ArgT0&& arg0, ArgT... args) {
 
 create_swap_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.create_swap_pool)
}
inline std::string* VoteCommissionData::mutable_create_swap_pool() {
  std::string* _s = _internal_mutable_create_swap_pool();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.create_swap_pool)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_create_swap_pool() const {
  return create_swap_pool_.Get();
}
inline void VoteCommissionData::_internal_set_create_swap_pool(const std::string& value) {
  
  create_swap_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_create_swap_pool() {
  
  return create_swap_pool_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_create_swap_pool() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.create_swap_pool)
  return create_swap_pool_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_create_swap_pool(std::string* create_swap_pool) {
  if (create_swap_pool != nullptr) {
    
  } else {
    
  }
  create_swap_pool_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_swap_pool,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.create_swap_pool)
}

// string add_liquidity = 49 [json_name = "addLiquidity"];
inline void VoteCommissionData::clear_add_liquidity() {
  add_liquidity_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::add_liquidity() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.add_liquidity)
  return _internal_add_liquidity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_add_liquidity(ArgT0&& arg0, ArgT... args) {
 
 add_liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.add_liquidity)
}
inline std::string* VoteCommissionData::mutable_add_liquidity() {
  std::string* _s = _internal_mutable_add_liquidity();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.add_liquidity)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_add_liquidity() const {
  return add_liquidity_.Get();
}
inline void VoteCommissionData::_internal_set_add_liquidity(const std::string& value) {
  
  add_liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_add_liquidity() {
  
  return add_liquidity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_add_liquidity() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.add_liquidity)
  return add_liquidity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_add_liquidity(std::string* add_liquidity) {
  if (add_liquidity != nullptr) {
    
  } else {
    
  }
  add_liquidity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), add_liquidity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.add_liquidity)
}

// string remove_liquidity = 50 [json_name = "removeLiquidity"];
inline void VoteCommissionData::clear_remove_liquidity() {
  remove_liquidity_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::remove_liquidity() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.remove_liquidity)
  return _internal_remove_liquidity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_remove_liquidity(ArgT0&& arg0, ArgT... args) {
 
 remove_liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.remove_liquidity)
}
inline std::string* VoteCommissionData::mutable_remove_liquidity() {
  std::string* _s = _internal_mutable_remove_liquidity();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.remove_liquidity)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_remove_liquidity() const {
  return remove_liquidity_.Get();
}
inline void VoteCommissionData::_internal_set_remove_liquidity(const std::string& value) {
  
  remove_liquidity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_remove_liquidity() {
  
  return remove_liquidity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_remove_liquidity() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.remove_liquidity)
  return remove_liquidity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_remove_liquidity(std::string* remove_liquidity) {
  if (remove_liquidity != nullptr) {
    
  } else {
    
  }
  remove_liquidity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remove_liquidity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.remove_liquidity)
}

// string edit_candidate_commission = 28 [json_name = "editCandidateCommission"];
inline void VoteCommissionData::clear_edit_candidate_commission() {
  edit_candidate_commission_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::edit_candidate_commission() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.edit_candidate_commission)
  return _internal_edit_candidate_commission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_edit_candidate_commission(ArgT0&& arg0, ArgT... args) {
 
 edit_candidate_commission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.edit_candidate_commission)
}
inline std::string* VoteCommissionData::mutable_edit_candidate_commission() {
  std::string* _s = _internal_mutable_edit_candidate_commission();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.edit_candidate_commission)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_edit_candidate_commission() const {
  return edit_candidate_commission_.Get();
}
inline void VoteCommissionData::_internal_set_edit_candidate_commission(const std::string& value) {
  
  edit_candidate_commission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_edit_candidate_commission() {
  
  return edit_candidate_commission_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_edit_candidate_commission() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.edit_candidate_commission)
  return edit_candidate_commission_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_edit_candidate_commission(std::string* edit_candidate_commission) {
  if (edit_candidate_commission != nullptr) {
    
  } else {
    
  }
  edit_candidate_commission_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edit_candidate_commission,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.edit_candidate_commission)
}

// string mint_token = 46 [json_name = "mintToken"];
inline void VoteCommissionData::clear_mint_token() {
  mint_token_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::mint_token() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.mint_token)
  return _internal_mint_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_mint_token(ArgT0&& arg0, ArgT... args) {
 
 mint_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.mint_token)
}
inline std::string* VoteCommissionData::mutable_mint_token() {
  std::string* _s = _internal_mutable_mint_token();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.mint_token)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_mint_token() const {
  return mint_token_.Get();
}
inline void VoteCommissionData::_internal_set_mint_token(const std::string& value) {
  
  mint_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_mint_token() {
  
  return mint_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_mint_token() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.mint_token)
  return mint_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_mint_token(std::string* mint_token) {
  if (mint_token != nullptr) {
    
  } else {
    
  }
  mint_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mint_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.mint_token)
}

// string burn_token = 47 [json_name = "burnToken"];
inline void VoteCommissionData::clear_burn_token() {
  burn_token_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::burn_token() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.burn_token)
  return _internal_burn_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_burn_token(ArgT0&& arg0, ArgT... args) {
 
 burn_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.burn_token)
}
inline std::string* VoteCommissionData::mutable_burn_token() {
  std::string* _s = _internal_mutable_burn_token();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.burn_token)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_burn_token() const {
  return burn_token_.Get();
}
inline void VoteCommissionData::_internal_set_burn_token(const std::string& value) {
  
  burn_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_burn_token() {
  
  return burn_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_burn_token() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.burn_token)
  return burn_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_burn_token(std::string* burn_token) {
  if (burn_token != nullptr) {
    
  } else {
    
  }
  burn_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), burn_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.burn_token)
}

// string vote_commission = 31 [json_name = "voteCommission"];
inline void VoteCommissionData::clear_vote_commission() {
  vote_commission_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::vote_commission() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.vote_commission)
  return _internal_vote_commission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_vote_commission(ArgT0&& arg0, ArgT... args) {
 
 vote_commission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.vote_commission)
}
inline std::string* VoteCommissionData::mutable_vote_commission() {
  std::string* _s = _internal_mutable_vote_commission();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.vote_commission)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_vote_commission() const {
  return vote_commission_.Get();
}
inline void VoteCommissionData::_internal_set_vote_commission(const std::string& value) {
  
  vote_commission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_vote_commission() {
  
  return vote_commission_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_vote_commission() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.vote_commission)
  return vote_commission_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_vote_commission(std::string* vote_commission) {
  if (vote_commission != nullptr) {
    
  } else {
    
  }
  vote_commission_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vote_commission,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.vote_commission)
}

// string vote_update = 32 [json_name = "voteUpdate"];
inline void VoteCommissionData::clear_vote_update() {
  vote_update_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::vote_update() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.vote_update)
  return _internal_vote_update();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_vote_update(ArgT0&& arg0, ArgT... args) {
 
 vote_update_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.vote_update)
}
inline std::string* VoteCommissionData::mutable_vote_update() {
  std::string* _s = _internal_mutable_vote_update();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.vote_update)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_vote_update() const {
  return vote_update_.Get();
}
inline void VoteCommissionData::_internal_set_vote_update(const std::string& value) {
  
  vote_update_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_vote_update() {
  
  return vote_update_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_vote_update() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.vote_update)
  return vote_update_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_vote_update(std::string* vote_update) {
  if (vote_update != nullptr) {
    
  } else {
    
  }
  vote_update_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vote_update,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.vote_update)
}

// string failed_tx = 56 [json_name = "failedTx"];
inline void VoteCommissionData::clear_failed_tx() {
  failed_tx_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::failed_tx() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.failed_tx)
  return _internal_failed_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_failed_tx(ArgT0&& arg0, ArgT... args) {
 
 failed_tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.failed_tx)
}
inline std::string* VoteCommissionData::mutable_failed_tx() {
  std::string* _s = _internal_mutable_failed_tx();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.failed_tx)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_failed_tx() const {
  return failed_tx_.Get();
}
inline void VoteCommissionData::_internal_set_failed_tx(const std::string& value) {
  
  failed_tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_failed_tx() {
  
  return failed_tx_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_failed_tx() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.failed_tx)
  return failed_tx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_failed_tx(std::string* failed_tx) {
  if (failed_tx != nullptr) {
    
  } else {
    
  }
  failed_tx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), failed_tx,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.failed_tx)
}

// string add_limit_order = 57 [json_name = "addLimitOrder"];
inline void VoteCommissionData::clear_add_limit_order() {
  add_limit_order_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::add_limit_order() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.add_limit_order)
  return _internal_add_limit_order();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_add_limit_order(ArgT0&& arg0, ArgT... args) {
 
 add_limit_order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.add_limit_order)
}
inline std::string* VoteCommissionData::mutable_add_limit_order() {
  std::string* _s = _internal_mutable_add_limit_order();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.add_limit_order)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_add_limit_order() const {
  return add_limit_order_.Get();
}
inline void VoteCommissionData::_internal_set_add_limit_order(const std::string& value) {
  
  add_limit_order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_add_limit_order() {
  
  return add_limit_order_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_add_limit_order() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.add_limit_order)
  return add_limit_order_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_add_limit_order(std::string* add_limit_order) {
  if (add_limit_order != nullptr) {
    
  } else {
    
  }
  add_limit_order_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), add_limit_order,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.add_limit_order)
}

// string remove_limit_order = 58 [json_name = "removeLimitOrder"];
inline void VoteCommissionData::clear_remove_limit_order() {
  remove_limit_order_.ClearToEmpty();
}
inline const std::string& VoteCommissionData::remove_limit_order() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteCommissionData.remove_limit_order)
  return _internal_remove_limit_order();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCommissionData::set_remove_limit_order(ArgT0&& arg0, ArgT... args) {
 
 remove_limit_order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteCommissionData.remove_limit_order)
}
inline std::string* VoteCommissionData::mutable_remove_limit_order() {
  std::string* _s = _internal_mutable_remove_limit_order();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteCommissionData.remove_limit_order)
  return _s;
}
inline const std::string& VoteCommissionData::_internal_remove_limit_order() const {
  return remove_limit_order_.Get();
}
inline void VoteCommissionData::_internal_set_remove_limit_order(const std::string& value) {
  
  remove_limit_order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::_internal_mutable_remove_limit_order() {
  
  return remove_limit_order_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCommissionData::release_remove_limit_order() {
  // @@protoc_insertion_point(field_release:api_pb.VoteCommissionData.remove_limit_order)
  return remove_limit_order_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCommissionData::set_allocated_remove_limit_order(std::string* remove_limit_order) {
  if (remove_limit_order != nullptr) {
    
  } else {
    
  }
  remove_limit_order_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remove_limit_order,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteCommissionData.remove_limit_order)
}

// -------------------------------------------------------------------

// VoteUpdateData

// string pub_key = 1 [json_name = "pubKey"];
inline void VoteUpdateData::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& VoteUpdateData::pub_key() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteUpdateData.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteUpdateData::set_pub_key(ArgT0&& arg0, ArgT... args) {
 
 pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteUpdateData.pub_key)
}
inline std::string* VoteUpdateData::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteUpdateData.pub_key)
  return _s;
}
inline const std::string& VoteUpdateData::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void VoteUpdateData::_internal_set_pub_key(const std::string& value) {
  
  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteUpdateData::_internal_mutable_pub_key() {
  
  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteUpdateData::release_pub_key() {
  // @@protoc_insertion_point(field_release:api_pb.VoteUpdateData.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteUpdateData::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    
  } else {
    
  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteUpdateData.pub_key)
}

// uint64 height = 2 [json_name = "height"];
inline void VoteUpdateData::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VoteUpdateData::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VoteUpdateData::height() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteUpdateData.height)
  return _internal_height();
}
inline void VoteUpdateData::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void VoteUpdateData::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:api_pb.VoteUpdateData.height)
}

// string version = 3 [json_name = "version"];
inline void VoteUpdateData::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& VoteUpdateData::version() const {
  // @@protoc_insertion_point(field_get:api_pb.VoteUpdateData.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteUpdateData::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.VoteUpdateData.version)
}
inline std::string* VoteUpdateData::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:api_pb.VoteUpdateData.version)
  return _s;
}
inline const std::string& VoteUpdateData::_internal_version() const {
  return version_.Get();
}
inline void VoteUpdateData::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteUpdateData::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteUpdateData::release_version() {
  // @@protoc_insertion_point(field_release:api_pb.VoteUpdateData.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteUpdateData::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.VoteUpdateData.version)
}

// -------------------------------------------------------------------

// AddLimitOrderData

// .api_pb.Coin coin_to_sell = 1 [json_name = "coinToSell"];
inline bool AddLimitOrderData::_internal_has_coin_to_sell() const {
  return this != internal_default_instance() && coin_to_sell_ != nullptr;
}
inline bool AddLimitOrderData::has_coin_to_sell() const {
  return _internal_has_coin_to_sell();
}
inline const ::api_pb::Coin& AddLimitOrderData::_internal_coin_to_sell() const {
  const ::api_pb::Coin* p = coin_to_sell_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& AddLimitOrderData::coin_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLimitOrderData.coin_to_sell)
  return _internal_coin_to_sell();
}
inline void AddLimitOrderData::unsafe_arena_set_allocated_coin_to_sell(
    ::api_pb::Coin* coin_to_sell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  coin_to_sell_ = coin_to_sell;
  if (coin_to_sell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.AddLimitOrderData.coin_to_sell)
}
inline ::api_pb::Coin* AddLimitOrderData::release_coin_to_sell() {
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* AddLimitOrderData::unsafe_arena_release_coin_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.AddLimitOrderData.coin_to_sell)
  
  ::api_pb::Coin* temp = coin_to_sell_;
  coin_to_sell_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* AddLimitOrderData::_internal_mutable_coin_to_sell() {
  
  if (coin_to_sell_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_sell_ = p;
  }
  return coin_to_sell_;
}
inline ::api_pb::Coin* AddLimitOrderData::mutable_coin_to_sell() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLimitOrderData.coin_to_sell)
  return _msg;
}
inline void AddLimitOrderData::set_allocated_coin_to_sell(::api_pb::Coin* coin_to_sell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell_);
  }
  if (coin_to_sell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_sell));
    if (message_arena != submessage_arena) {
      coin_to_sell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_sell, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_sell_ = coin_to_sell;
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLimitOrderData.coin_to_sell)
}

// string value_to_sell = 2 [json_name = "valueToSell"];
inline void AddLimitOrderData::clear_value_to_sell() {
  value_to_sell_.ClearToEmpty();
}
inline const std::string& AddLimitOrderData::value_to_sell() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLimitOrderData.value_to_sell)
  return _internal_value_to_sell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLimitOrderData::set_value_to_sell(ArgT0&& arg0, ArgT... args) {
 
 value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.AddLimitOrderData.value_to_sell)
}
inline std::string* AddLimitOrderData::mutable_value_to_sell() {
  std::string* _s = _internal_mutable_value_to_sell();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLimitOrderData.value_to_sell)
  return _s;
}
inline const std::string& AddLimitOrderData::_internal_value_to_sell() const {
  return value_to_sell_.Get();
}
inline void AddLimitOrderData::_internal_set_value_to_sell(const std::string& value) {
  
  value_to_sell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddLimitOrderData::_internal_mutable_value_to_sell() {
  
  return value_to_sell_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddLimitOrderData::release_value_to_sell() {
  // @@protoc_insertion_point(field_release:api_pb.AddLimitOrderData.value_to_sell)
  return value_to_sell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddLimitOrderData::set_allocated_value_to_sell(std::string* value_to_sell) {
  if (value_to_sell != nullptr) {
    
  } else {
    
  }
  value_to_sell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_sell,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLimitOrderData.value_to_sell)
}

// .api_pb.Coin coin_to_buy = 3 [json_name = "coinToBuy"];
inline bool AddLimitOrderData::_internal_has_coin_to_buy() const {
  return this != internal_default_instance() && coin_to_buy_ != nullptr;
}
inline bool AddLimitOrderData::has_coin_to_buy() const {
  return _internal_has_coin_to_buy();
}
inline const ::api_pb::Coin& AddLimitOrderData::_internal_coin_to_buy() const {
  const ::api_pb::Coin* p = coin_to_buy_;
  return p != nullptr ? *p : reinterpret_cast<const ::api_pb::Coin&>(
      ::api_pb::_Coin_default_instance_);
}
inline const ::api_pb::Coin& AddLimitOrderData::coin_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLimitOrderData.coin_to_buy)
  return _internal_coin_to_buy();
}
inline void AddLimitOrderData::unsafe_arena_set_allocated_coin_to_buy(
    ::api_pb::Coin* coin_to_buy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  coin_to_buy_ = coin_to_buy;
  if (coin_to_buy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api_pb.AddLimitOrderData.coin_to_buy)
}
inline ::api_pb::Coin* AddLimitOrderData::release_coin_to_buy() {
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api_pb::Coin* AddLimitOrderData::unsafe_arena_release_coin_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.AddLimitOrderData.coin_to_buy)
  
  ::api_pb::Coin* temp = coin_to_buy_;
  coin_to_buy_ = nullptr;
  return temp;
}
inline ::api_pb::Coin* AddLimitOrderData::_internal_mutable_coin_to_buy() {
  
  if (coin_to_buy_ == nullptr) {
    auto* p = CreateMaybeMessage<::api_pb::Coin>(GetArenaForAllocation());
    coin_to_buy_ = p;
  }
  return coin_to_buy_;
}
inline ::api_pb::Coin* AddLimitOrderData::mutable_coin_to_buy() {
  ::api_pb::Coin* _msg = _internal_mutable_coin_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLimitOrderData.coin_to_buy)
  return _msg;
}
inline void AddLimitOrderData::set_allocated_coin_to_buy(::api_pb::Coin* coin_to_buy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy_);
  }
  if (coin_to_buy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coin_to_buy));
    if (message_arena != submessage_arena) {
      coin_to_buy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_to_buy, submessage_arena);
    }
    
  } else {
    
  }
  coin_to_buy_ = coin_to_buy;
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLimitOrderData.coin_to_buy)
}

// string value_to_buy = 4 [json_name = "valueToBuy"];
inline void AddLimitOrderData::clear_value_to_buy() {
  value_to_buy_.ClearToEmpty();
}
inline const std::string& AddLimitOrderData::value_to_buy() const {
  // @@protoc_insertion_point(field_get:api_pb.AddLimitOrderData.value_to_buy)
  return _internal_value_to_buy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLimitOrderData::set_value_to_buy(ArgT0&& arg0, ArgT... args) {
 
 value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api_pb.AddLimitOrderData.value_to_buy)
}
inline std::string* AddLimitOrderData::mutable_value_to_buy() {
  std::string* _s = _internal_mutable_value_to_buy();
  // @@protoc_insertion_point(field_mutable:api_pb.AddLimitOrderData.value_to_buy)
  return _s;
}
inline const std::string& AddLimitOrderData::_internal_value_to_buy() const {
  return value_to_buy_.Get();
}
inline void AddLimitOrderData::_internal_set_value_to_buy(const std::string& value) {
  
  value_to_buy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddLimitOrderData::_internal_mutable_value_to_buy() {
  
  return value_to_buy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddLimitOrderData::release_value_to_buy() {
  // @@protoc_insertion_point(field_release:api_pb.AddLimitOrderData.value_to_buy)
  return value_to_buy_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddLimitOrderData::set_allocated_value_to_buy(std::string* value_to_buy) {
  if (value_to_buy != nullptr) {
    
  } else {
    
  }
  value_to_buy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_to_buy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:api_pb.AddLimitOrderData.value_to_buy)
}

// -------------------------------------------------------------------

// RemoveLimitOrderData

// uint64 id = 1 [json_name = "id"];
inline void RemoveLimitOrderData::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoveLimitOrderData::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoveLimitOrderData::id() const {
  // @@protoc_insertion_point(field_get:api_pb.RemoveLimitOrderData.id)
  return _internal_id();
}
inline void RemoveLimitOrderData::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void RemoveLimitOrderData::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:api_pb.RemoveLimitOrderData.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api_pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_data_2eproto
